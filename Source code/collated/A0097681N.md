# A0097681N
###### Parser\CommandTokeniser.cpp
``` cpp
#include "CommandTokeniser.h"
#include "DateParser.h"

CommandTokeniser::CommandTokeniser(void) {
	// nothing here
}

CommandTokeniser::~CommandTokeniser(void) {
	// nothing here
}

boost::posix_time::ptime CommandTokeniser::parseUserInputDate(std::string userInputDate) {
	return DateParser::parse(userInputDate);
}

bool CommandTokeniser::isRegexMatch(const std::string* userInput, std::string regexString) {
	return std::regex_match(*userInput,
	                        std::regex(regexString,
	                                   std::regex_constants::ECMAScript | std::regex_constants::icase));
}

std::smatch CommandTokeniser::getRegexMatches(const std::string* userInput, std::string regexString) {
	std::smatch matchResults;
	std::regex_match(*userInput,
	                 matchResults,
	                 std::regex(regexString,
	                            std::regex_constants::ECMAScript | std::regex_constants::icase));
	return matchResults;
}
```
###### Parser\CommandTokeniser.h
``` h
#pragma once
#include <regex>
#include "CommandTokens.h"

// abstract class used to create concrete class for processing each kind of
// command;
// usage: implement canTokeniseUserInput() to return true for user input that
// the concrete class is supposed to process; implement tokeniserUserInput()
// for actual tokenising of the user input
class CommandTokeniser {
public:
	CommandTokeniser(void);
	virtual ~CommandTokeniser(void);

	virtual CommandTokens tokeniseUserInput(std::string userInput) = 0;
	virtual bool canTokeniseUserInput(std::string userInput) = 0;

protected:
	// utility methods for common user input processing tasks
	boost::posix_time::ptime parseUserInputDate(std::string userInputDate);
	bool isRegexMatch(const std::string* userInput, std::string regexString);
	std::smatch getRegexMatches(const std::string* userInput, std::string regexString);
};
```
###### Parser\CommandTokens.cpp
``` cpp
#include "CommandTokens.h"

// complete constructor, with default arguments initialised to sentinel values
CommandTokens::CommandTokens(PrimaryCommandType primaryCommandType,
                             SecondaryCommandType secondaryCommandType,
                             std::string taskName,
                             boost::posix_time::ptime startDateTime,
                             boost::posix_time::ptime endDateTime,
                             std::vector<std::string> tags,
                             int index) :
	_primaryCommandType(primaryCommandType),
	_secondaryCommandType(secondaryCommandType),
	_taskName(taskName),
	_startDateTime(startDateTime),
	_endDateTime(endDateTime),
	_tags(tags),
	_index(index) {
}

void CommandTokens::reset() {
	_primaryCommandType = Invalid;
	_secondaryCommandType = None;
	_taskName = "";
	_tags.clear();
	_index = -1;

	boost::posix_time::ptime notAPtime;
	_startDateTime = notAPtime;
	_endDateTime = notAPtime;
}

bool CommandTokens::isValid() {
	return _primaryCommandType == Invalid;
}

CommandTokens::PrimaryCommandType CommandTokens::getPrimaryCommand() {
	return _primaryCommandType;
}

CommandTokens::SecondaryCommandType CommandTokens::getSecondaryCommand() {
	return _secondaryCommandType;
}

std::string CommandTokens::getTaskName() {
	return _taskName;
}

std::vector<std::string>& CommandTokens::getTags() {
	return _tags;
}

boost::posix_time::ptime CommandTokens::getStartDateTime() {
	return _startDateTime;
}

boost::posix_time::ptime CommandTokens::getEndDateTime() {
	return _endDateTime;
}

int CommandTokens::getIndex() {
	return _index;
}

std::string CommandTokens::getOtherCommandParameter() {
	return _otherCommandParameter;
}

void CommandTokens::setPrimaryCommand(PrimaryCommandType newPrimaryCommand) {
	_primaryCommandType = newPrimaryCommand;
}

void CommandTokens::setSecondaryCommand(SecondaryCommandType newSecondaryCommand) {
	_secondaryCommandType = newSecondaryCommand;
}

void CommandTokens::setTaskName(std::string newTaskName) {
	_taskName = newTaskName;
}

void CommandTokens::setTags(std::vector<std::string> newTags) {
	_tags = newTags;
}

void CommandTokens::setStartDateTime(boost::posix_time::ptime newStartDateTime) {
	_startDateTime = newStartDateTime;
}

void CommandTokens::setEndDateTime(boost::posix_time::ptime newEndDateTime) {
	_endDateTime = newEndDateTime;
}

void CommandTokens::setIndex(int newIndex) {
	_index = newIndex;
}

void CommandTokens::setOtherCommandParameter(std::string newOtherCommandParameter) {
	_otherCommandParameter = newOtherCommandParameter;
}
```
###### Parser\CommandTokens.h
``` h
#pragma once
#include <exception>
#include <vector>
#include "boost\date_time\posix_time\ptime.hpp"

// wrapper class to contain the various components of a user input that has
// been tokenised
class CommandTokens {
public:
	// Command Type for main groups of operation
	enum PrimaryCommandType {
		Invalid,

		// administrative commands
		Help,
		Configure,
		Refresh,
		Undo,

		// task management commands
		Add, Display, Edit, Delete,
		Search,	Sort,
		Tag, Untag,
		MarkAsComplete,
		Export,	Import
	};

	// Command Type to further specify the operation
	enum SecondaryCommandType {
		None,

		// general task filters
		All, Index,
		FromTo, By,	Floating,
		Completed,
		Name, Start, End,
		Tags,

		// specific task filters
		EndAfter,EndBefore,
		StartAfter,	StartBefore,
		FreeSlot,

		// miscellaneous
		SaveLocation
	};

	CommandTokens(PrimaryCommandType primaryCommandType = Invalid,
	              SecondaryCommandType secondaryCommandType = None,
	              std::string taskName = "",
	              boost::posix_time::ptime startDateTime = boost::posix_time::ptime(),
	              boost::posix_time::ptime endDateTime = boost::posix_time::ptime(),
	              std::vector<std::string> tags = std::vector<std::string>(0),
	              int index = -1);

	bool isValid();
	void reset();

	PrimaryCommandType getPrimaryCommand();
	SecondaryCommandType getSecondaryCommand();
	std::string getTaskName();
	std::vector<std::string>& getTags();
	boost::posix_time::ptime getStartDateTime();
	boost::posix_time::ptime getEndDateTime();
	int getIndex();
	std::string getOtherCommandParameter();

	void setPrimaryCommand(PrimaryCommandType newPrimaryCommand);
	void setSecondaryCommand(SecondaryCommandType newSecondaryCommand);
	void setTaskName(std::string newTaskName);
	void setTags(std::vector<std::string> newTags);
	void setStartDateTime(boost::posix_time::ptime newStartDateTime);
	void setEndDateTime(boost::posix_time::ptime newEndDateTime);
	void setIndex(int newIndex);
	void setOtherCommandParameter(std::string newOtherCommandParameter);

private:
	PrimaryCommandType _primaryCommandType;
	SecondaryCommandType _secondaryCommandType;
	std::string _taskName;
	boost::posix_time::ptime _startDateTime;
	boost::posix_time::ptime _endDateTime;
	std::vector<std::string> _tags;
	int _index;
	std::string _otherCommandParameter;
};
```
###### Parser\DateParser.cpp
``` cpp
#include "DateParser.h"
#include "boost\date_time\posix_time\time_parsers.hpp"

DateParser::DateParser(void) {
	// nothing here
}

boost::posix_time::ptime DateParser::parse(std::string userInputDateString) {
	boost::posix_time::ptime retVal;

	if (isLocallySupportedDateFormat(userInputDateString)) {
		std::string formattedDateString = convertToFormattedDateString(userInputDateString);
		retVal = getPtimeObject(formattedDateString);

	} else if (isBoostLibrarySupportedDateFormat(userInputDateString)) {
		retVal = getPtimeObject(userInputDateString);

	} else {
		retVal = getInvalidPtimeObject();
	}

	return retVal;
}

bool DateParser::isLocallySupportedDateFormat(std::string userInputDateString) {
	if (isDDMMYY(userInputDateString) ||
		isDDMMYYYY_TTTT(userInputDateString)) {
		return true;
	}
	return false;
}

// checks if userInputDateString is in a format supported by Boost Library
// by passing it as parameter to in-built function
// if exception is thrown, format is not supported;
// otherwise, format is supported
bool DateParser::isBoostLibrarySupportedDateFormat(std::string userInputDateString) {
	try {
		boost::posix_time::time_from_string(userInputDateString);
		return true;
	} catch (std::exception e) {
		return false;
	}
}

std::string DateParser::convertToFormattedDateString(std::string userInputDateString) {
	std::string formattedDateString = "";

	if (isDDMMYY(userInputDateString)) {
		formattedDateString = parseDDMMYYYY(userInputDateString);
	} else if (isDDMMYYYY_TTTT(userInputDateString)) {
		formattedDateString = parseDDMMYYYY_TTTT(userInputDateString);
	}

	return formattedDateString;
}

boost::posix_time::ptime DateParser::getPtimeObject(std::string formattedDateString) {
	boost::posix_time::ptime retVal;

	try {
		retVal = boost::posix_time::ptime(boost::posix_time::time_from_string(formattedDateString));
	} catch (std::exception e) {
		retVal = getInvalidPtimeObject();
	}

	return retVal;
}

boost::posix_time::ptime DateParser::getInvalidPtimeObject() {
	return boost::posix_time::ptime();
}

bool DateParser::isDDMMYY(std::string dateString) {
	return std::regex_match(dateString,
	                        std::regex("[0-9]{2}-[0-9]{2}-[0-9]{4}",
	                                   std::regex_constants::ECMAScript | std::regex_constants::icase));
}

bool DateParser::isDDMMYYYY_TTTT(std::string dateString) {
	return std::regex_match(dateString,
	                        std::regex("[0-9]{2}-[0-9]{2}-[0-9]{4} [0-9]{2}[0-9]{2}",
	                                   std::regex_constants::ECMAScript | std::regex_constants::icase));
}

std::string DateParser::parseDDMMYYYY(std::string dateString) {
	std::smatch matchResults;
	std::regex_match(dateString, matchResults,
	                 std::regex("([0-9]{2})-([0-9]{2})-([0-9]{4})",
	                            std::regex_constants::ECMAScript | std::regex_constants::icase));

	std::string day, month, year, hour, minute, formattedDateString;
	day = matchResults[1];
	month = matchResults[2];
	year = matchResults[3];
	hour = "00";
	minute = "00";
	formattedDateString = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":00.000";

	return formattedDateString;
}

std::string DateParser::parseDDMMYYYY_TTTT(std::string dateString) {
	std::smatch matchResults;
	std::regex_match(dateString, matchResults,
	                 std::regex("([0-9]{2})-([0-9]{2})-([0-9]{4}) ([0-9]{2})([0-9]{2})",
	                            std::regex_constants::ECMAScript | std::regex_constants::icase));

	std::string day, month, year, hour, minute, formattedDateString;
	day = matchResults[1];
	month = matchResults[2];
	year = matchResults[3];
	hour = matchResults[4];
	minute = matchResults[5];
	formattedDateString = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":00.000";

	return formattedDateString;
}
```
###### Parser\DateParser.h
``` h
#pragma once
#include <regex>
#include "../boost/date_time/posix_time/ptime.hpp"

class DateParser {
public:
	DateParser(void);
	static boost::posix_time::ptime parse(std::string dateString);

private:
	static bool isLocallySupportedDateFormat(std::string userInputDateString);
	static bool isBoostLibrarySupportedDateFormat(std::string userInputDateString);

	static std::string convertToFormattedDateString(std::string userInputDateString);
	static boost::posix_time::ptime getPtimeObject(std::string formattedDateString);
	static boost::posix_time::ptime getInvalidPtimeObject(void);

	static bool isDDMMYYYY_TTTT(std::string dateString);
	static bool isDDMMYY(std::string dateString);
	static std::string parseDDMMYYYY_TTTT(std::string dateString);
	static std::string parseDDMMYYYY(std::string dateString);
};
```
###### Parser\Parser.cpp
``` cpp
#include "Parser.h"

#include "CommandTokenisers\AddCommandTokeniser.h"
#include "CommandTokenisers\ConfigureCommandTokeniser.h"
#include "CommandTokenisers\CompleteCommandTokeniser.h"
#include "CommandTokenisers\DeleteCommandTokeniser.h"
#include "CommandTokenisers\DisplayCommandTokeniser.h"
#include "CommandTokenisers\ExportCommandTokeniser.h"
#include "CommandTokenisers\EditCommandTokeniser.h"
#include "CommandTokenisers\ImportCommandTokeniser.h"
#include "CommandTokenisers\RefreshCommandTokeniser.h"
#include "CommandTokenisers\SearchCommandTokeniser.h"
#include "CommandTokenisers\SortCommandTokeniser.h"
#include "CommandTokenisers\TagCommandTokeniser.h"
#include "CommandTokenisers\UndoCommandTokeniser.h"
#include "CommandTokenisers\UntagCommandTokeniser.h"

Parser::Parser(void) {
	_logger = Logger::getInstance();

	initialiseAllCommandTokenisers();
	initialiseInvalidCommandTokens();
}

void Parser::initialiseAllCommandTokenisers() {
	_commandTokenisers.push_back(new AddCommandTokeniser);
	_commandTokenisers.push_back(new ConfigureCommandTokeniser);
	_commandTokenisers.push_back(new CompleteCommandTokeniser);
	_commandTokenisers.push_back(new DeleteCommandTokeniser);
	_commandTokenisers.push_back(new DisplayCommandTokeniser);
	_commandTokenisers.push_back(new ExportCommandTokeniser);
	_commandTokenisers.push_back(new EditCommandTokeniser);
	_commandTokenisers.push_back(new ImportCommandTokeniser);
	_commandTokenisers.push_back(new RefreshCommandTokeniser);
	_commandTokenisers.push_back(new SearchCommandTokeniser);
	_commandTokenisers.push_back(new SortCommandTokeniser);
	_commandTokenisers.push_back(new TagCommandTokeniser);
	_commandTokenisers.push_back(new UndoCommandTokeniser);
	_commandTokenisers.push_back(new UntagCommandTokeniser);
}

void Parser::initialiseInvalidCommandTokens() {
	_invalidCommandTokens.setPrimaryCommand(CommandTokens::PrimaryCommandType::Invalid);
	_invalidCommandTokens.setSecondaryCommand(CommandTokens::SecondaryCommandType::None);
}

CommandTokens Parser::parse(std::string userInput) {
	_logger->logINFO("Parser::parse(std::string userInput):CommandTokens called with parameter userInput=\"" + userInput + "\"");

	CommandTokeniser* commandTokeniser = getCommandTokeniser(userInput);
	if (commandTokeniser == nullptr) {
		return _invalidCommandTokens;
	}
	return commandTokeniser->tokeniseUserInput(userInput);
}

CommandTokeniser* Parser::getCommandTokeniser(std::string userInput) {
	for (CommandTokeniser* commandTokeniser : _commandTokenisers) {
		if (commandTokeniser->canTokeniseUserInput(userInput)) {
			return commandTokeniser;
		}
	}
	return nullptr;
}
```
###### Parser\Parser.h
``` h
#pragma once
#include <regex>
#include "CommandTokens.h"
#include "CommandTokeniser.h"
#include "Logger\Logger.h"

// facade class to provide uniform way to assess the various concrete
// CommandTokeniser classes
class Parser {
public:
	Parser(void);
	CommandTokens parse(std::string userInput);

private:
	Logger* _logger;

	std::vector<CommandTokeniser*> _commandTokenisers;
	CommandTokens _invalidCommandTokens;

	void initialiseAllCommandTokenisers(void);
	void initialiseInvalidCommandTokens(void);
	CommandTokeniser* getCommandTokeniser(std::string userInput);
};
```
###### ParserTest\ParserTest.cpp
``` cpp
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ParserTest {
	TEST_CLASS(ParserTester) {
	public:
		Parser _parser;

		TEST_METHOD(unitTest_parser_TokeniseAddFromTo) {
			std::string testUserInput = "ADD activityTask FROM 2002-01-20 23:59:59.000 TO 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;

			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Add,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "activityTask",
			                                      "2002-01-20 23:59:59.000",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseAddBy) {
			std::string testUserInput = "ADD todoTask BY 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;

			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Add,
			                                      CommandTokens::SecondaryCommandType::By,
			                                      "todoTask",
			                                      "",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseAddFloating) {
			std::string testUserInput = "ADD floatingTask";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Add,
			                                      CommandTokens::SecondaryCommandType::Floating,
			                                      "floatingTask",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseComplete) {
			std::string testUserInput = "COMPLETE 11";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::MarkAsComplete,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      11);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseConfigureSaveLocation) {
			std::string testUserInput = "CONFIGURE SAVE LOCATION D:\\";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Configure,
			                                      CommandTokens::SecondaryCommandType::SaveLocation,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			expected.setOtherCommandParameter("D:\\");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteAll) {
			std::string testUserInput = "DELETE ALL";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::All,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteCompleted) {
			std::string testUserInput = "DELETE COMPLETED";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::Completed,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteIndex) {
			std::string testUserInput = "DELETE 3";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      3);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteBy) {
			std::string testUserInput = "DELETE BY 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::By,
			                                      "",
			                                      "",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteFromTo) {
			std::string testUserInput = "DELETE FROM 2002-01-20 23:59:59.000 TO 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteFrom) {
			std::string testUserInput = "DELETE FROM 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayAll) {
			std::string testUserInput = "DISPLAY ALL";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::All,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayActivity) {
			std::string testUserInput = "DISPLAY ACTIVITY";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayFloating) {
			std::string testUserInput = "DISPLAY FLOATING";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::Floating,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayTodo) {
			std::string testUserInput = "DISPLAY TODO";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::By,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseEditName) {
			std::string testUserInput = "EDIT NAME 3 newTaskName";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Edit,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "newTaskName",
			                                      "",
			                                      "",
			                                      3);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseEditStartDate) {
			std::string testUserInput = "EDIT START 5 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Edit,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      5);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseEditEndDate) {
			std::string testUserInput = "EDIT END 7 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Edit,
			                                      CommandTokens::SecondaryCommandType::End,
			                                      "",
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      7);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseExport) {
			std::string testUserInput = "EXPORT C:\\";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Export,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			expected.setOtherCommandParameter("C:\\");

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseImport) {
			std::string testUserInput = "IMPORT D:\\aRandomFile.txt";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Import,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			expected.setOtherCommandParameter("D:\\aRandomFile.txt");

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseRefresh) {
			std::string testUserInput = "REFRESH";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Refresh,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchName) {
			std::string testUserInput = "SEARCH NAME a Random Task";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "a Random Task",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchFromTo) {
			std::string testUserInput = "SEARCH FROM 2002-01-20 23:59:59.000 TO 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchFreeSlot) {
			std::string testUserInput = "SEARCH FREE";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::FreeSlot,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchStartBefore) {
			std::string testUserInput = "SEARCH START BEFORE 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::StartBefore,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchStartAfter) {
			std::string testUserInput = "SEARCH START AFTER 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::StartAfter,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchEndBefore) {
			std::string testUserInput = "SEARCH END BEFORE 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::EndBefore,
			                                      "",
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchEndAfter) {
			std::string testUserInput = "SEARCH END AFTER 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::EndAfter,
			                                      "",
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchTags) {
			std::string testUserInput = "SEARCH TAGS #123";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::Tags,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			std::vector<std::string> newTags;
			newTags.push_back("#123");
			expected.setTags(newTags);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortName) {
			std::string testUserInput = "SORT NAME";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Ascending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortNameDesc) {
			std::string testUserInput = "SORT NAME DESC";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Descending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortStart) {
			std::string testUserInput = "SORT START";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Ascending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortStartDesc) {
			std::string testUserInput = "SORT START DESC";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Descending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortEnd) {
			std::string testUserInput = "SORT END";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::End,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Ascending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortEndDesc) {
			std::string testUserInput = "SORT END DESC";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::End,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Descending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseTag) {
			std::string testUserInput = "TAG 19 #123 #abc";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Tag,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      19);
			std::vector<std::string> newTags;
			newTags.push_back("#123");
			newTags.push_back("#abc");
			expected.setTags(newTags);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseUndo) {
			std::string testUserInput = "UNDO";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Undo,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseUntag) {
			std::string testUserInput = "UNTAG 23 #12c #ab3";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Untag,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      23);
			std::vector<std::string> newTags;
			newTags.push_back("#12c");
			newTags.push_back("#ab3");
			expected.setTags(newTags);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH) {
			std::string testUserInputDate = "13-05-1999 1320";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("1999-05-13 13:20:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY) {
			std::string testUserInputDate = "13-05-1999";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("1999-05-13 00:00:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		// upper boundary case for valid date range partition
		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH_MaxRange) {
			std::string testUserInputDate = "31-12-9999 2359";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("9999-12-31 23:59:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		// lower boundary case for valid date range partition
		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH_MinRange) {
			std::string testUserInputDate = "01-01-1400 0000";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("1400-01-01 00:00:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		// edge cases partition: dates that are invalid because of non-uniform length of months
		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH_InvalidDate) {
			std::string testUserInputDate = "29-02-1999 1345";

			boost::posix_time::ptime expected;
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		CommandTokens buildExpectedCommandTokens(CommandTokens::PrimaryCommandType primaryCommandType,
		                                         CommandTokens::SecondaryCommandType secondaryCommandType,
		                                         std::string taskName,
		                                         std::string startDate,
		                                         std::string endDate,
		                                         int index) {

			CommandTokens expected;

			expected.setPrimaryCommand(primaryCommandType);
			expected.setSecondaryCommand(secondaryCommandType);
			expected.setTaskName(taskName);
			expected.setIndex(index);

			// if an empty string is passed in, the command has no startDate
			if (startDate == "") {
				boost::posix_time::ptime notAPtime; // default constructor gives a not_a_date_time object
				expected.setStartDateTime(notAPtime);
			} else {
				boost::posix_time::ptime expectedStartDate(boost::posix_time::time_from_string(startDate));
				expected.setStartDateTime(expectedStartDate);
			}

			// if an empty string is passed in, the command has no endDate
			if (endDate == "") {
				boost::posix_time::ptime notAPtime; // default constructor gives a not_a_date_time object
				expected.setEndDateTime(notAPtime);
			} else {
				boost::posix_time::ptime expectedEndDate(boost::posix_time::time_from_string(endDate));
				expected.setEndDateTime(expectedEndDate);
			}

			return expected;
		}

		void compareCommandTokens(CommandTokens expected, CommandTokens actual) {

			Assert::AreEqual(int(expected.getPrimaryCommand()), int(actual.getPrimaryCommand()));
			Assert::AreEqual(int(expected.getSecondaryCommand()), int(actual.getSecondaryCommand()));
			Assert::AreEqual(expected.getTaskName(), actual.getTaskName());
			Assert::IsTrue(expected.getStartDateTime() == actual.getStartDateTime());
			Assert::IsTrue(expected.getEndDateTime() == actual.getEndDateTime());
			Assert::AreEqual(expected.getIndex(), actual.getIndex());
			Assert::AreEqual(expected.getOtherCommandParameter(), actual.getOtherCommandParameter());

			std::vector<std::string> expectedTags, actualTags;
			expectedTags = expected.getTags();
			actualTags = actual.getTags();

			// checks if tags are both empty, else iterates through each element and assert equality
			Assert::AreEqual(expectedTags.empty(), actualTags.empty());
			if (!expectedTags.empty()) {
				for (unsigned i = 0; i < expectedTags.size(); i++) {
					Assert::AreEqual(expectedTags.at(i), actualTags.at(i));
				}
			}
		}
	};
}
```
