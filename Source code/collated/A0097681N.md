# A0097681N
###### Parser\CommandTokeniser.cpp
``` cpp
#include "CommandTokeniser.h"
#include "DateParser.h"

CommandTokeniser::CommandTokeniser(void) {
	// nothing here
}

CommandTokeniser::~CommandTokeniser(void) {
	// nothing here
}

boost::posix_time::ptime CommandTokeniser::parseUserInputDate(std::string userInputDate) {
	return DateParser::parse(userInputDate);
}

bool CommandTokeniser::isRegexMatch(const std::string* userInput, std::string regexString) {
	return std::regex_match(*userInput,
	                        std::regex(regexString,
	                                   std::regex_constants::ECMAScript | std::regex_constants::icase));
}

std::smatch CommandTokeniser::getRegexMatches(const std::string* userInput, std::string regexString) {
	std::smatch matchResults;
	std::regex_match(*userInput,
	                 matchResults,
	                 std::regex(regexString,
	                            std::regex_constants::ECMAScript | std::regex_constants::icase));
	return matchResults;
}
```
###### Parser\CommandTokeniser.h
``` h
#pragma once
#include <regex>
#include "CommandTokens.h"

// abstract class used to create concrete class for processing each kind of
// command;
// usage: implement canTokeniseUserInput() to return true for user input that
// the concrete class is supposed to process; implement tokeniserUserInput()
// for actual tokenising of the user input
class CommandTokeniser {
public:
	CommandTokeniser(void);
	virtual ~CommandTokeniser(void);

	virtual CommandTokens tokeniseUserInput(std::string userInput) = 0;
	virtual bool canTokeniseUserInput(std::string userInput) = 0;

protected:
	// utility methods for common user input processing tasks
	boost::posix_time::ptime parseUserInputDate(std::string userInputDate);
	bool isRegexMatch(const std::string* userInput, std::string regexString);
	std::smatch getRegexMatches(const std::string* userInput, std::string regexString);
};
```
###### Parser\CommandTokenisers\AddCommandTokeniser.cpp
``` cpp
#include "AddCommandTokeniser.h"

AddCommandTokeniser::AddCommandTokeniser(void) {
	// nothing here
}

AddCommandTokeniser::~AddCommandTokeniser(void) {
	// nothing here
}

bool AddCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isAddFromTo(userInput) ||
		isAddBy(userInput) ||
		isAddFloating(userInput)) {
		return true;
	}
	return false;
}

CommandTokens AddCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Add);

	if (isTagged(userInput)) {
		tokeniseTags(userInput, &tokenisedCommand);
		userInput = trimTags(userInput);
	}

	if (isAddFromTo(userInput)) {
		tokeniseAddFromTo(userInput, &tokenisedCommand);

	} else if (isAddBy(userInput)) {
		tokeniseAddBy(userInput, &tokenisedCommand);

	} else if (isAddFloating(userInput)) {
		tokeniseAddFloating(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool AddCommandTokeniser::isTagged(std::string userInput) {
	return isRegexMatch(&userInput, ".+?( #[^ ]+)+");
}

void AddCommandTokeniser::tokeniseTags(std::string userInput, CommandTokens* tokenisedCommand) {
	std::vector<std::string> newTags;

	std::smatch matchResults;
	while (std::regex_search(userInput, matchResults,
	                         std::regex(" (#[^ ]+)",
	                                    std::regex_constants::ECMAScript))) {

		newTags.push_back(matchResults[1]);

		// continue the search in the right substring
		userInput = matchResults.suffix().str();
	}

	tokenisedCommand->setTags(newTags);
}

std::string AddCommandTokeniser::trimTags(std::string userInput) {
	int endIndex = userInput.find(" #");
	return userInput.substr(0, endIndex);
}

bool AddCommandTokeniser::isAddFromTo(std::string userInput) {
	return isRegexMatch(&userInput, "ADD .+ FROM .+ TO .+");
}

bool AddCommandTokeniser::isAddBy(std::string userInput) {
	return isRegexMatch(&userInput, "ADD .+ BY .+");
}

bool AddCommandTokeniser::isAddFloating(std::string userInput) {
	return isRegexMatch(&userInput, "ADD .+");
}

void AddCommandTokeniser::tokeniseAddFromTo(std::string userInput, CommandTokens* tokenisedCommand) {
	tokenisedCommand->setSecondaryCommand(CommandTokens::SecondaryCommandType::FromTo);

	std::smatch matchResults = getRegexMatches(&userInput, "ADD (.+) FROM (.+) TO (.+)");

	std::string taskName = matchResults[1];
	boost::posix_time::ptime startDateTime = parseUserInputDate(matchResults[2]);
	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[3]);

	tokenisedCommand->setTaskName(taskName);
	tokenisedCommand->setStartDateTime(startDateTime);
	tokenisedCommand->setEndDateTime(endDateTime);
}

void AddCommandTokeniser::tokeniseAddBy(std::string userInput, CommandTokens* tokenisedCommand) {
	tokenisedCommand->setSecondaryCommand(CommandTokens::SecondaryCommandType::By);
	
	std::smatch matchResults = getRegexMatches(&userInput, "ADD (.+) BY (.+)");

	std::string taskName = matchResults[1];
	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[2]);

	tokenisedCommand->setTaskName(taskName);
	tokenisedCommand->setEndDateTime(endDateTime);
}

void AddCommandTokeniser::tokeniseAddFloating(std::string userInput, CommandTokens* tokenisedCommand) {
	tokenisedCommand->setSecondaryCommand(CommandTokens::SecondaryCommandType::Floating);

	std::smatch matchResults = getRegexMatches(&userInput, "ADD (.+)");

	std::string taskName = matchResults[1];
	tokenisedCommand->setTaskName(taskName);
}
```
###### Parser\CommandTokenisers\AddCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class AddCommandTokeniser : public CommandTokeniser {
public:
	AddCommandTokeniser(void);
	virtual ~AddCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isAddFromTo(std::string userInput);
	bool isAddBy(std::string userInput);
	bool isAddFloating(std::string userInput);

	void tokeniseAddFromTo(std::string userInput, CommandTokens* tokenisedCommand);
	void tokeniseAddBy(std::string userInput, CommandTokens* tokenisedCommand);
	void tokeniseAddFloating(std::string userInput, CommandTokens* tokenisedCommand);

	bool isTagged(std::string userInput);
	void tokeniseTags(std::string userInput, CommandTokens* tokenisedCommand);	
	std::string trimTags(std::string userInput);
};
```
###### Parser\CommandTokenisers\CompleteCommandTokeniser.cpp
``` cpp
#include "CompleteCommandTokeniser.h"

CompleteCommandTokeniser::CompleteCommandTokeniser(void) {
	// nothing here
}

CompleteCommandTokeniser::~CompleteCommandTokeniser(void) {
	// nothing here
}

bool CompleteCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isCompleteIndex(userInput)) {
		return true;
	}
	return false;
}

CommandTokens CompleteCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::MarkAsComplete);

	if (isCompleteIndex(userInput)) {
		tokeniseCompleteIndex(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool CompleteCommandTokeniser::isCompleteIndex(std::string userInput) {
	return isRegexMatch(&userInput, "COMPLETE [0-9]+");
}

void CompleteCommandTokeniser::tokeniseCompleteIndex(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Index);

	std::smatch matchResults = getRegexMatches(&userInput, "COMPLETE ([0-9]+)");

	int index = std::stoi(matchResults[1]);
	outputCommandTokens->setIndex(index);
}
```
###### Parser\CommandTokenisers\CompleteCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class CompleteCommandTokeniser : public CommandTokeniser {
public:
	CompleteCommandTokeniser(void);
	virtual ~CompleteCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isCompleteIndex(std::string userInput);
	void tokeniseCompleteIndex(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\ConfigureCommandTokeniser.cpp
``` cpp
#include "ConfigureCommandTokeniser.h"

ConfigureCommandTokeniser::ConfigureCommandTokeniser(void) {
	// nothing here
}

ConfigureCommandTokeniser::~ConfigureCommandTokeniser(void) {
	// nothing here
}

bool ConfigureCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isConfigureSaveLocation(userInput)) {
		return true;
	}
	return false;
}

CommandTokens ConfigureCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Configure);

	if (isConfigureSaveLocation(userInput)) {
		tokeniseConfigureSaveLocation(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool ConfigureCommandTokeniser::isConfigureSaveLocation(std::string userInput) {
	return isRegexMatch(&userInput, "CONFIGURE SAVE LOCATION .+");
}

void ConfigureCommandTokeniser::tokeniseConfigureSaveLocation(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::SaveLocation);

	std::smatch matchResults = getRegexMatches(&userInput, "CONFIGURE SAVE LOCATION (.+)");

	std::string saveLocation = matchResults[1];
	outputCommandTokens->setOtherCommandParameter(saveLocation);
}
```
###### Parser\CommandTokenisers\ConfigureCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class ConfigureCommandTokeniser : public CommandTokeniser {
public:
	ConfigureCommandTokeniser(void);
	virtual ~ConfigureCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isConfigureSaveLocation(std::string userInput);
	void tokeniseConfigureSaveLocation(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\DeleteCommandTokeniser.cpp
``` cpp
#include "DeleteCommandTokeniser.h"

DeleteCommandTokeniser::DeleteCommandTokeniser(void) {
	// nothing here
}

DeleteCommandTokeniser::~DeleteCommandTokeniser(void) {
	// nothing here
}

bool DeleteCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isDeleteAll(userInput) ||
		isDeleteCompleted(userInput) ||
		isDeleteIndex(userInput) ||
		isDeleteFromTo(userInput) ||
		isDeleteFrom(userInput) ||
		isDeleteBy(userInput)) {
		return true;
	}
	return false;
}

CommandTokens DeleteCommandTokeniser::tokeniseUserInput(::std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Delete);

	if (isDeleteAll(userInput)) {
		tokeniseDeleteAll(&tokenisedCommand);

	} else if (isDeleteCompleted(userInput)) {
		tokeniseDeleteCompleted(userInput, &tokenisedCommand);

	} else if (isDeleteIndex(userInput)) {
		tokeniseDeleteIndex(userInput, &tokenisedCommand);

	} else if (isDeleteFromTo(userInput)) {
		tokeniseDeleteFromTo(userInput, &tokenisedCommand);

	} else if (isDeleteFrom(userInput)) {
		tokeniseDeleteFrom(userInput, &tokenisedCommand);

	} else if (isDeleteBy(userInput)) {
		tokeniseDeleteBy(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool DeleteCommandTokeniser::isDeleteAll(std::string userInput) {
	return isRegexMatch(&userInput, "DELETE ALL");
}

bool DeleteCommandTokeniser::isDeleteCompleted(std::string userInput) {
	return isRegexMatch(&userInput, "DELETE COMPLETED");
}

bool DeleteCommandTokeniser::isDeleteIndex(std::string userInput) {
	return isRegexMatch(&userInput, "DELETE [0-9]+");
}

bool DeleteCommandTokeniser::isDeleteFromTo(std::string userInput) {
	return isRegexMatch(&userInput, "DELETE FROM .+ TO .+");
}

bool DeleteCommandTokeniser::isDeleteFrom(std::string userInput) {
	return isRegexMatch(&userInput, "DELETE FROM .+");
}

bool DeleteCommandTokeniser::isDeleteBy(std::string userInput) {
	return isRegexMatch(&userInput, "DELETE BY .+");
}

void DeleteCommandTokeniser::tokeniseDeleteAll(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::All);
}

void DeleteCommandTokeniser::tokeniseDeleteCompleted(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Completed);
}

void DeleteCommandTokeniser::tokeniseDeleteIndex(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Index);

	std::smatch matchResults = getRegexMatches(&userInput, "DELETE ([0-9]+)");

	int index = stoi(matchResults[1]);
	outputCommandTokens->setIndex(index);
}

void DeleteCommandTokeniser::tokeniseDeleteFromTo(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::FromTo);

	std::smatch matchResults = getRegexMatches(&userInput, "DELETE FROM (.+) TO (.+)");

	boost::posix_time::ptime startDateTime = parseUserInputDate(matchResults[1]);
	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[2]);

	outputCommandTokens->setStartDateTime(startDateTime);
	outputCommandTokens->setEndDateTime(endDateTime);
}

void DeleteCommandTokeniser::tokeniseDeleteFrom(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Start);

	std::smatch matchResults = getRegexMatches(&userInput, "DELETE FROM (.+)");

	boost::posix_time::ptime startDateTime = parseUserInputDate(matchResults[1]);
	outputCommandTokens->setStartDateTime(startDateTime);
}

void DeleteCommandTokeniser::tokeniseDeleteBy(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::By);

	std::smatch matchResults = getRegexMatches(&userInput, "DELETE BY (.+)");

	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[1]);
	outputCommandTokens->setEndDateTime(endDateTime);
}
```
###### Parser\CommandTokenisers\DeleteCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class DeleteCommandTokeniser : public CommandTokeniser {
public:
	DeleteCommandTokeniser(void);
	virtual ~DeleteCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isDeleteAll(std::string userInput);
	bool isDeleteCompleted(std::string userInput);
	bool isDeleteIndex(std::string userInput);
	bool isDeleteBy(std::string userInput);
	bool isDeleteFromTo(std::string userInput);
	bool isDeleteFrom(std::string userInput);

	void tokeniseDeleteAll(CommandTokens* outputCommandTokens);
	void tokeniseDeleteCompleted(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseDeleteIndex(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseDeleteBy(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseDeleteFromTo(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseDeleteFrom(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\DisplayCommandTokeniser.cpp
``` cpp
#include "DisplayCommandTokeniser.h"

DisplayCommandTokeniser::DisplayCommandTokeniser(void) {
	// nothing here
}

DisplayCommandTokeniser::~DisplayCommandTokeniser(void) {
	// nothing here
}

bool DisplayCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isDisplayAll(userInput) ||
		isDisplayFloating(userInput) ||
		isDisplayActivity(userInput) ||
		isDisplayTodo(userInput)) {
		return true;
	}
	return false;
}

CommandTokens DisplayCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Display);

	if (isDisplayAll(userInput)) {
		tokeniseDisplayAll(&tokenisedCommand);

	} else if (isDisplayActivity(userInput)) {
		tokeniseDisplayActivity(&tokenisedCommand);

	} else if (isDisplayTodo(userInput)) {
		tokeniseDisplayTodo(&tokenisedCommand);

	} else if (isDisplayFloating(userInput)) {
		tokeniseDisplayFloating(&tokenisedCommand);
	}

	return tokenisedCommand;
}

void DisplayCommandTokeniser::tokeniseDisplayAll(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::All);
}

void DisplayCommandTokeniser::tokeniseDisplayActivity(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::FromTo);
}

void DisplayCommandTokeniser::tokeniseDisplayTodo(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::By);
}

void DisplayCommandTokeniser::tokeniseDisplayFloating(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Floating);
}

bool DisplayCommandTokeniser::isDisplayAll(std::string userInput) {
	return isRegexMatch(&userInput, "DISPLAY ALL");
}

bool DisplayCommandTokeniser::isDisplayActivity(std::string userInput) {
	return isRegexMatch(&userInput, "DISPLAY ACTIVITY");
}

bool DisplayCommandTokeniser::isDisplayTodo(std::string userInput) {
	return isRegexMatch(&userInput, "DISPLAY TODO");
}

bool DisplayCommandTokeniser::isDisplayFloating(std::string userInput) {
	return isRegexMatch(&userInput, "DISPLAY FLOATING");
}
```
###### Parser\CommandTokenisers\DisplayCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class DisplayCommandTokeniser : public CommandTokeniser {
public:
	DisplayCommandTokeniser(void);
	virtual ~DisplayCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isDisplayAll(std::string userInput);
	bool isDisplayActivity(std::string userInput);
	bool isDisplayTodo(std::string userInput);
	bool isDisplayFloating(std::string userInput);

	void tokeniseDisplayAll(CommandTokens* outputCommandTokens);
	void tokeniseDisplayActivity(CommandTokens* outputCommandTokens);
	void tokeniseDisplayTodo(CommandTokens* outputCommandTokens);
	void tokeniseDisplayFloating(CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\EditCommandTokeniser.cpp
``` cpp
#include "EditCommandTokeniser.h"

EditCommandTokeniser::EditCommandTokeniser(void) {
	// nothing here
}

EditCommandTokeniser::~EditCommandTokeniser(void) {
	// nothing here
}

bool EditCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isEditName(userInput) ||
		isEditEndDate(userInput) ||
		isEditStartDate(userInput)) {
		return true;
	}
	return false;
}

CommandTokens EditCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Edit);

	if (isEditName(userInput)) {
		tokeniseEditName(userInput, &tokenisedCommand);

	} else if (isEditStartDate(userInput)) {
		tokeniseEditStartDate(userInput, &tokenisedCommand);

	} else if (isEditEndDate(userInput)) {
		tokeniseEditEndDate(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool EditCommandTokeniser::isEditName(std::string userInput) {
	return isRegexMatch(&userInput, "EDIT NAME [0-9]+ .+");
}

bool EditCommandTokeniser::isEditStartDate(std::string userInput) {
	return isRegexMatch(&userInput, "EDIT START [0-9]+ .+");
}

bool EditCommandTokeniser::isEditEndDate(std::string userInput) {
	return isRegexMatch(&userInput, "EDIT END [0-9]+ .+");
}

void EditCommandTokeniser::tokeniseEditName(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Name);

	std::smatch matchResults = getRegexMatches(&userInput, "EDIT NAME ([0-9]+) (.+)");

	int index = stoi(matchResults[1]);
	std::string taskName = matchResults[2];

	outputCommandTokens->setIndex(index);
	outputCommandTokens->setTaskName(taskName);
}

void EditCommandTokeniser::tokeniseEditStartDate(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Start);

	std::smatch matchResults = getRegexMatches(&userInput, "EDIT START ([0-9]+) (.+)");

	int index = stoi(matchResults[1]);
	boost::posix_time::ptime startDate = parseUserInputDate(matchResults[2]);

	outputCommandTokens->setIndex(index);
	outputCommandTokens->setStartDateTime(startDate);
}

void EditCommandTokeniser::tokeniseEditEndDate(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::End);

	std::smatch matchResults = getRegexMatches(&userInput, "EDIT END ([0-9]+) (.+)");

	int index = stoi(matchResults[1]);
	boost::posix_time::ptime endDate = parseUserInputDate(matchResults[2]);

	outputCommandTokens->setIndex(index);
	outputCommandTokens->setEndDateTime(endDate);
}
```
###### Parser\CommandTokenisers\EditCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class EditCommandTokeniser : public CommandTokeniser {
public:
	EditCommandTokeniser(void);
	virtual ~EditCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isEditName(std::string userInput);
	bool isEditStartDate(std::string userInput);
	bool isEditEndDate(std::string userInput);

	void tokeniseEditName(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseEditStartDate(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseEditEndDate(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\ExportCommandTokeniser.cpp
``` cpp
#include "ExportCommandTokeniser.h"

ExportCommandTokeniser::ExportCommandTokeniser(void) {
	// nothing here
}

ExportCommandTokeniser::~ExportCommandTokeniser(void) {
	// nothing here
}

bool ExportCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isExportToLocalDisk(userInput)) {
		return true;
	}
	return false;
}

CommandTokens ExportCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Export);

	if (isExportToLocalDisk(userInput)) {
		tokeniseExportToLocalDisk(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool ExportCommandTokeniser::isExportToLocalDisk(std::string userInput) {
	return isRegexMatch(&userInput,"EXPORT .+");
}

void ExportCommandTokeniser::tokeniseExportToLocalDisk(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::None);

	std::smatch matchResults = getRegexMatches(&userInput, "EXPORT (.+)");

	std::string exportPath = matchResults[1];
	outputCommandTokens->setOtherCommandParameter(exportPath);
}
```
###### Parser\CommandTokenisers\ExportCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class ExportCommandTokeniser : public CommandTokeniser {
public:
	ExportCommandTokeniser(void);
	virtual ~ExportCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isExportToLocalDisk(std::string userInput);
	void tokeniseExportToLocalDisk(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\ImportCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class ImportCommandTokeniser : public CommandTokeniser {
public:
	ImportCommandTokeniser(void);
	virtual ~ImportCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isImportLocal(std::string userInput);
	void tokeniseImportLocal(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\RefreshCommandTokeniser.cpp
``` cpp
#include "RefreshCommandTokeniser.h"

RefreshCommandTokeniser::RefreshCommandTokeniser(void) {
	// nothing
}

RefreshCommandTokeniser::~RefreshCommandTokeniser(void) {
	// nothing
}

bool RefreshCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isRefreshBasic(userInput)) {
		return true;
	}
	return false;
}

CommandTokens RefreshCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Refresh);

	if (isRefreshBasic(userInput)) {
		tokeniseRefreshBasic(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool RefreshCommandTokeniser::isRefreshBasic(std::string userInput) {
	return isRegexMatch(&userInput, "REFRESH");
}

void RefreshCommandTokeniser::tokeniseRefreshBasic(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::None);
}
```
###### Parser\CommandTokenisers\RefreshCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class RefreshCommandTokeniser : public CommandTokeniser {
public:
	RefreshCommandTokeniser(void);
	virtual ~RefreshCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isRefreshBasic(std::string userInput);
	void tokeniseRefreshBasic(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\SearchCommandTokeniser.cpp
``` cpp
#include "SearchCommandTokeniser.h"

SearchCommandTokeniser::SearchCommandTokeniser(void) {
	// nothing
}

SearchCommandTokeniser::~SearchCommandTokeniser(void) {
	// nothing
}

bool SearchCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isSearchFreeSlot(userInput) ||
		isSearchName(userInput) ||
		isSearchFromTo(userInput) ||
		isSearchStartBefore(userInput) ||
		isSearchStartAfter(userInput) ||
		isSearchEndBefore(userInput) ||
		isSearchEndAfter(userInput) ||
		isSearchTags(userInput)) {
		return true;
	}
	return false;
}

CommandTokens SearchCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Search);

	if (isSearchFreeSlot(userInput)) {
		tokeniseSearchFreeSlot(&tokenisedCommand);

	} else if (isSearchName(userInput)) {
		tokeniseSearchName(userInput, &tokenisedCommand);

	} else if (isSearchFromTo(userInput)) {
		tokeniseSearchFromTo(userInput, &tokenisedCommand);

	} else if (isSearchStartBefore(userInput)) {
		tokeniseSearchStartBefore(userInput, &tokenisedCommand);

	} else if (isSearchStartAfter(userInput)) {
		tokeniseSearchStartAfter(userInput, &tokenisedCommand);

	} else if (isSearchEndBefore(userInput)) {
		tokeniseSearchEndBefore(userInput, &tokenisedCommand);

	} else if (isSearchEndAfter(userInput)) {
		tokeniseSearchEndAfter(userInput, &tokenisedCommand);

	} else if (isSearchTags(userInput)) {
		tokeniseSearchTags(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool SearchCommandTokeniser::isSearchFreeSlot(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH FREE");
}

bool SearchCommandTokeniser::isSearchName(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH NAME .+");
}

bool SearchCommandTokeniser::isSearchFromTo(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH FROM .+ TO .+");
}

bool SearchCommandTokeniser::isSearchStartBefore(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH START BEFORE .+");
}

bool SearchCommandTokeniser::isSearchStartAfter(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH START AFTER .+");
}

bool SearchCommandTokeniser::isSearchEndBefore(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH END BEFORE .+");
}

bool SearchCommandTokeniser::isSearchEndAfter(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH END AFTER .+");
}

bool SearchCommandTokeniser::isSearchTags(std::string userInput) {
	return isRegexMatch(&userInput, "SEARCH TAGS( #[^ ]+)+");
}

void SearchCommandTokeniser::tokeniseSearchFreeSlot(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::FreeSlot);
}

void SearchCommandTokeniser::tokeniseSearchName(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Name);

	std::smatch matchResults = getRegexMatches(&userInput, "SEARCH NAME (.+)");

	std::string taskNameToSearch = matchResults[1];
	outputCommandTokens->setTaskName(taskNameToSearch);
}

void SearchCommandTokeniser::tokeniseSearchFromTo(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::FromTo);

	std::smatch matchResults = getRegexMatches(&userInput, "SEARCH FROM (.+) TO (.+)");

	boost::posix_time::ptime startDateTime = parseUserInputDate(matchResults[1]);
	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[2]);
	outputCommandTokens->setStartDateTime(startDateTime);
	outputCommandTokens->setEndDateTime(endDateTime);
}

void SearchCommandTokeniser::tokeniseSearchStartBefore(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::StartBefore);

	std::smatch matchResults = getRegexMatches(&userInput, "SEARCH START BEFORE (.+)");

	boost::posix_time::ptime startDateTime = parseUserInputDate(matchResults[1]);
	outputCommandTokens->setStartDateTime(startDateTime);
}

void SearchCommandTokeniser::tokeniseSearchStartAfter(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::StartAfter);

	std::smatch matchResults = getRegexMatches(&userInput, "SEARCH START AFTER (.+)");

	boost::posix_time::ptime startDateTime = parseUserInputDate(matchResults[1]);
	outputCommandTokens->setStartDateTime(startDateTime);
}

void SearchCommandTokeniser::tokeniseSearchEndBefore(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::EndBefore);

	std::smatch matchResults = getRegexMatches(&userInput, "SEARCH END BEFORE (.+)");

	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[1]);
	outputCommandTokens->setEndDateTime(endDateTime);
}

void SearchCommandTokeniser::tokeniseSearchEndAfter(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::EndAfter);

	std::smatch matchResults = getRegexMatches(&userInput, "SEARCH END AFTER (.+)");

	boost::posix_time::ptime endDateTime = parseUserInputDate(matchResults[1]);
	outputCommandTokens->setEndDateTime(endDateTime);
}

void SearchCommandTokeniser::tokeniseSearchTags(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Tags);

	std::vector<std::string> tokenisedTags;
	std::smatch matchResults;
	while (std::regex_search(userInput, matchResults,
	                         std::regex(" (#[^ ]+)",
	                                    std::regex_constants::ECMAScript | std::regex_constants::icase))) {

		tokenisedTags.push_back(matchResults[1]);

		// continue the search in the right substring
		userInput = matchResults.suffix().str();
	}

	outputCommandTokens->setTags(tokenisedTags);
}
```
###### Parser\CommandTokenisers\SearchCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class SearchCommandTokeniser : public CommandTokeniser {
public:
	SearchCommandTokeniser(void);
	virtual ~SearchCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isSearchFreeSlot(std::string userInput);
	bool isSearchName(std::string userInput);
	bool isSearchFromTo(std::string userInput);
	bool isSearchStartBefore(std::string userInput);
	bool isSearchStartAfter(std::string userInput);
	bool isSearchEndBefore(std::string userInput);
	bool isSearchEndAfter(std::string userInput);
	bool isSearchTags(std::string userInput);
	
	void tokeniseSearchFreeSlot(CommandTokens* outputCommandTokens);
	void tokeniseSearchName(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSearchFromTo(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSearchStartBefore(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSearchStartAfter(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSearchEndBefore(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSearchEndAfter(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSearchTags(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\SortCommandTokeniser.cpp
``` cpp
#include "SortCommandTokeniser.h"

SortCommandTokeniser::SortCommandTokeniser(void) {
	// nothing here
}

SortCommandTokeniser::~SortCommandTokeniser(void) {
	// nothing here
}

bool SortCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isSortName(userInput) ||
		isSortStart(userInput) ||
		isSortEnd(userInput)) {
		return true;
	}
	return false;
}

CommandTokens SortCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Sort);

	if (isSortName(userInput)) {
		tokeniseSortName(userInput, &tokenisedCommand);

	} else if (isSortStart(userInput)) {
		tokeniseSortStart(userInput, &tokenisedCommand);

	} else if (isSortEnd(userInput)) {
		tokeniseSortEnd(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool SortCommandTokeniser::isSortName(std::string userInput) {
	return isRegexMatch(&userInput, "SORT NAME( DESC)?");
}

bool SortCommandTokeniser::isSortStart(std::string userInput) {
	return isRegexMatch(&userInput, "SORT START( DESC)?");
}

bool SortCommandTokeniser::isSortEnd(std::string userInput) {
	return isRegexMatch(&userInput, "SORT END( DESC)?");
}

void SortCommandTokeniser::tokeniseSortName(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Name);

	std::string sortOrder = getSortOrder(userInput);
	outputCommandTokens->setOtherCommandParameter(sortOrder);
}

void SortCommandTokeniser::tokeniseSortStart(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Start);

	std::string sortOrder = getSortOrder(userInput);
	outputCommandTokens->setOtherCommandParameter(sortOrder);
}

void SortCommandTokeniser::tokeniseSortEnd(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::End);

	std::string sortOrder = getSortOrder(userInput);
	outputCommandTokens->setOtherCommandParameter(sortOrder);
}

std::string SortCommandTokeniser::getSortOrder(std::string userInput) {
	std::string sortOrder = "Ascending";

	if (std::regex_match(userInput,
	                     std::regex(".+ DESC",
	                                std::regex_constants::ECMAScript | std::regex_constants::icase))) {
		sortOrder = "Descending";
	}

	return sortOrder;
}
```
###### Parser\CommandTokenisers\SortCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class SortCommandTokeniser : public CommandTokeniser {
public:
	SortCommandTokeniser(void);
	virtual ~SortCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isSortName(std::string userInput);
	bool isSortStart(std::string userInput);
	bool isSortEnd(std::string userInput);

	void tokeniseSortName(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSortStart(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseSortEnd(std::string userInput, CommandTokens* outputCommandTokens);

	std::string getSortOrder(std::string userInput);
};
```
###### Parser\CommandTokenisers\TagCommandTokeniser.cpp
``` cpp
#include "TagCommandTokeniser.h"

TagCommandTokeniser::TagCommandTokeniser(void) {
	// nothing here
}

TagCommandTokeniser::~TagCommandTokeniser(void) {
	// nothing here
}

bool TagCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isTagIndex(userInput)) {
		return true;
	}
	return false;
}

CommandTokens TagCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Tag);

	if (isTagIndex(userInput)) {
		tokeniseTagIndex(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool TagCommandTokeniser::isTagIndex(std::string userInput) {
	return isRegexMatch(&userInput, "TAG [0-9]+( (#[^ ]+))+");
}

void TagCommandTokeniser::tokeniseTagIndex(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Index);

	std::smatch matchResults = getRegexMatches(&userInput, "TAG ([0-9]+) .*");

	int index = stoi(matchResults[1]);
	outputCommandTokens->setIndex(index);

	tokeniseTags(userInput, outputCommandTokens);
}

void TagCommandTokeniser::tokeniseTags(std::string userInput, CommandTokens* outputCommandTokens) {
	std::vector<std::string> newTags;

	std::smatch matchResults;
	while (std::regex_search(userInput, matchResults,
	                         std::regex(" (#[^ ]+)",
	                                    std::regex_constants::ECMAScript | std::regex_constants::icase))) {

		newTags.push_back(matchResults[1]);

		// continue the search in the right substring
		userInput = matchResults.suffix().str();
	}

	outputCommandTokens->setTags(newTags);
}
```
###### Parser\CommandTokenisers\TagCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class TagCommandTokeniser : public CommandTokeniser {
public:
	TagCommandTokeniser(void);
	virtual ~TagCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isTagIndex(std::string userInput);
	void tokeniseTagIndex(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseTags(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\UndoCommandTokeniser.cpp
``` cpp
#include "UndoCommandTokeniser.h"

UndoCommandTokeniser::UndoCommandTokeniser(void) {
	// nothing here
}

UndoCommandTokeniser::~UndoCommandTokeniser(void) {
	// nothing here
}

bool UndoCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isUndoOnce(userInput)) {
		return true;
	}
	return false;
}

CommandTokens UndoCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Undo);

	if (isUndoOnce(userInput)) {
		tokeniseUndoOnce(&tokenisedCommand);
	}

	return tokenisedCommand;
}

bool UndoCommandTokeniser::isUndoOnce(std::string userInput) {
	return isRegexMatch(&userInput, "UNDO");
}

void UndoCommandTokeniser::tokeniseUndoOnce(CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::None);
}
```
###### Parser\CommandTokenisers\UndoCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class UndoCommandTokeniser : public CommandTokeniser {
public:
	UndoCommandTokeniser(void);
	virtual ~UndoCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isUndoOnce(std::string userInput);
	void tokeniseUndoOnce(CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokenisers\UntagCommandTokeniser.cpp
``` cpp
#include "UntagCommandTokeniser.h"

UntagCommandTokeniser::UntagCommandTokeniser(void) {
	// nothing here
}

UntagCommandTokeniser::~UntagCommandTokeniser(void) {
	// nothing here
}

bool UntagCommandTokeniser::canTokeniseUserInput(std::string userInput) {
	if (isUntagIndex(userInput)) {
		return true;
	}
	return false;
}

CommandTokens UntagCommandTokeniser::tokeniseUserInput(std::string userInput) {
	assert(canTokeniseUserInput(userInput));

	CommandTokens tokenisedCommand(CommandTokens::PrimaryCommandType::Untag);

	if (isUntagIndex(userInput)) {
		tokeniseUntagIndex(userInput, &tokenisedCommand);
	}

	return tokenisedCommand;
}

bool UntagCommandTokeniser::isUntagIndex(std::string userInput) {
	return isRegexMatch(&userInput, "UNTAG [0-9]+( (#[^ ]+))+");
}

void UntagCommandTokeniser::tokeniseUntagIndex(std::string userInput, CommandTokens* outputCommandTokens) {
	outputCommandTokens->setSecondaryCommand(CommandTokens::SecondaryCommandType::Index);

	std::smatch matchResults = getRegexMatches(&userInput, "UNTAG ([0-9]+) .*");

	int index = stoi(matchResults[1]);
	outputCommandTokens->setIndex(index);

	tokeniseTags(userInput, outputCommandTokens);
}

void UntagCommandTokeniser::tokeniseTags(std::string userInput, CommandTokens* outputCommandTokens) {
	std::vector<std::string> newTags;
	std::smatch matchResults;
	while (std::regex_search(userInput, matchResults,
	                         std::regex(" (#[^ ]+)",
	                                    std::regex_constants::ECMAScript | std::regex_constants::icase))) {

		newTags.push_back(matchResults[1]);

		// continue the search in the right substring
		userInput = matchResults.suffix().str();
	}

	outputCommandTokens->setTags(newTags);
}
```
###### Parser\CommandTokenisers\UntagCommandTokeniser.h
``` h
#pragma once
#include "..\CommandTokeniser.h"

class UntagCommandTokeniser : public CommandTokeniser {
public:
	UntagCommandTokeniser(void);
	virtual ~UntagCommandTokeniser(void);

	virtual bool canTokeniseUserInput(std::string userInput) override;
	virtual CommandTokens tokeniseUserInput(std::string userInput) override;

private:
	bool isUntagIndex(std::string userInput);
	void tokeniseUntagIndex(std::string userInput, CommandTokens* outputCommandTokens);
	void tokeniseTags(std::string userInput, CommandTokens* outputCommandTokens);
};
```
###### Parser\CommandTokens.cpp
``` cpp
#include "CommandTokens.h"

// complete constructor, with default arguments initialised to sentinel values
CommandTokens::CommandTokens(PrimaryCommandType primaryCommandType,
                             SecondaryCommandType secondaryCommandType,
                             std::string taskName,
                             boost::posix_time::ptime startDateTime,
                             boost::posix_time::ptime endDateTime,
                             std::vector<std::string> tags,
                             int index) :
	_primaryCommandType(primaryCommandType),
	_secondaryCommandType(secondaryCommandType),
	_taskName(taskName),
	_startDateTime(startDateTime),
	_endDateTime(endDateTime),
	_tags(tags),
	_index(index) {
}

void CommandTokens::reset() {
	_primaryCommandType = Invalid;
	_secondaryCommandType = None;
	_taskName = "";
	_tags.clear();
	_index = -1;

	boost::posix_time::ptime notAPtime;
	_startDateTime = notAPtime;
	_endDateTime = notAPtime;
}

bool CommandTokens::isValid() {
	return _primaryCommandType == Invalid;
}

CommandTokens::PrimaryCommandType CommandTokens::getPrimaryCommand() {
	return _primaryCommandType;
}

CommandTokens::SecondaryCommandType CommandTokens::getSecondaryCommand() {
	return _secondaryCommandType;
}

std::string CommandTokens::getTaskName() {
	return _taskName;
}

std::vector<std::string>& CommandTokens::getTags() {
	return _tags;
}

boost::posix_time::ptime CommandTokens::getStartDateTime() {
	return _startDateTime;
}

boost::posix_time::ptime CommandTokens::getEndDateTime() {
	return _endDateTime;
}

int CommandTokens::getIndex() {
	return _index;
}

std::string CommandTokens::getOtherCommandParameter() {
	return _otherCommandParameter;
}

void CommandTokens::setPrimaryCommand(PrimaryCommandType newPrimaryCommand) {
	_primaryCommandType = newPrimaryCommand;
}

void CommandTokens::setSecondaryCommand(SecondaryCommandType newSecondaryCommand) {
	_secondaryCommandType = newSecondaryCommand;
}

void CommandTokens::setTaskName(std::string newTaskName) {
	_taskName = newTaskName;
}

void CommandTokens::setTags(std::vector<std::string> newTags) {
	_tags = newTags;
}

void CommandTokens::setStartDateTime(boost::posix_time::ptime newStartDateTime) {
	_startDateTime = newStartDateTime;
}

void CommandTokens::setEndDateTime(boost::posix_time::ptime newEndDateTime) {
	_endDateTime = newEndDateTime;
}

void CommandTokens::setIndex(int newIndex) {
	_index = newIndex;
}

void CommandTokens::setOtherCommandParameter(std::string newOtherCommandParameter) {
	_otherCommandParameter = newOtherCommandParameter;
}
```
###### Parser\CommandTokens.h
``` h
#pragma once
#include <exception>
#include <vector>
#include "boost\date_time\posix_time\ptime.hpp"

// wrapper class to contain the various components of a user input that has
// been tokenised
class CommandTokens {
public:
	// Command Type for main groups of operation
	enum PrimaryCommandType {
		Invalid,

		// administrative commands
		Help,
		Configure,
		Refresh,
		Undo,

		// task management commands
		Add, Display, Edit, Delete,
		Search,	Sort,
		Tag, Untag,
		MarkAsComplete,
		Export,	Import
	};

	// Command Type to further specify the operation
	enum SecondaryCommandType {
		None,

		// general task filters
		All, Index,
		FromTo, By,	Floating,
		Completed,
		Name, Start, End,
		Tags,

		// specific task filters
		EndAfter,EndBefore,
		StartAfter,	StartBefore,
		FreeSlot,

		// miscellaneous
		SaveLocation
	};

	CommandTokens(PrimaryCommandType primaryCommandType = Invalid,
	              SecondaryCommandType secondaryCommandType = None,
	              std::string taskName = "",
	              boost::posix_time::ptime startDateTime = boost::posix_time::ptime(),
	              boost::posix_time::ptime endDateTime = boost::posix_time::ptime(),
	              std::vector<std::string> tags = std::vector<std::string>(0),
	              int index = -1);

	bool isValid();
	void reset();

	PrimaryCommandType getPrimaryCommand();
	SecondaryCommandType getSecondaryCommand();
	std::string getTaskName();
	std::vector<std::string>& getTags();
	boost::posix_time::ptime getStartDateTime();
	boost::posix_time::ptime getEndDateTime();
	int getIndex();
	std::string getOtherCommandParameter();

	void setPrimaryCommand(PrimaryCommandType newPrimaryCommand);
	void setSecondaryCommand(SecondaryCommandType newSecondaryCommand);
	void setTaskName(std::string newTaskName);
	void setTags(std::vector<std::string> newTags);
	void setStartDateTime(boost::posix_time::ptime newStartDateTime);
	void setEndDateTime(boost::posix_time::ptime newEndDateTime);
	void setIndex(int newIndex);
	void setOtherCommandParameter(std::string newOtherCommandParameter);

private:
	PrimaryCommandType _primaryCommandType;
	SecondaryCommandType _secondaryCommandType;
	std::string _taskName;
	boost::posix_time::ptime _startDateTime;
	boost::posix_time::ptime _endDateTime;
	std::vector<std::string> _tags;
	int _index;
	std::string _otherCommandParameter;
};
```
###### Parser\DateParser.cpp
``` cpp
#include "DateParser.h"
#include "boost\date_time\posix_time\time_parsers.hpp"

DateParser::DateParser(void) {
	// nothing here
}

boost::posix_time::ptime DateParser::parse(std::string userInputDateString) {
	boost::posix_time::ptime retVal;

	if (isLocallySupportedDateFormat(userInputDateString)) {
		std::string formattedDateString = convertToFormattedDateString(userInputDateString);
		retVal = getPtimeObject(formattedDateString);

	} else if (isBoostLibrarySupportedDateFormat(userInputDateString)) {
		retVal = getPtimeObject(userInputDateString);

	} else {
		retVal = getInvalidPtimeObject();
	}

	return retVal;
}

bool DateParser::isLocallySupportedDateFormat(std::string userInputDateString) {
	if (isDDMMYY(userInputDateString) ||
		isDDMMYYYY_TTTT(userInputDateString)) {
		return true;
	}
	return false;
}

// checks if userInputDateString is in a format supported by Boost Library
// by passing it as parameter to in-built function
// if exception is thrown, format is not supported;
// otherwise, format is supported
bool DateParser::isBoostLibrarySupportedDateFormat(std::string userInputDateString) {
	try {
		boost::posix_time::time_from_string(userInputDateString);
		return true;
	} catch (std::exception e) {
		return false;
	}
}

std::string DateParser::convertToFormattedDateString(std::string userInputDateString) {
	std::string formattedDateString = "";

	if (isDDMMYY(userInputDateString)) {
		formattedDateString = parseDDMMYYYY(userInputDateString);
	} else if (isDDMMYYYY_TTTT(userInputDateString)) {
		formattedDateString = parseDDMMYYYY_TTTT(userInputDateString);
	}

	return formattedDateString;
}

boost::posix_time::ptime DateParser::getPtimeObject(std::string formattedDateString) {
	boost::posix_time::ptime retVal;

	try {
		retVal = boost::posix_time::ptime(boost::posix_time::time_from_string(formattedDateString));
	} catch (std::exception e) {
		retVal = getInvalidPtimeObject();
	}

	return retVal;
}

boost::posix_time::ptime DateParser::getInvalidPtimeObject() {
	return boost::posix_time::ptime();
}

bool DateParser::isDDMMYY(std::string dateString) {
	return std::regex_match(dateString,
	                        std::regex("[0-9]{2}-[0-9]{2}-[0-9]{4}",
	                                   std::regex_constants::ECMAScript | std::regex_constants::icase));
}

bool DateParser::isDDMMYYYY_TTTT(std::string dateString) {
	return std::regex_match(dateString,
	                        std::regex("[0-9]{2}-[0-9]{2}-[0-9]{4} [0-9]{2}[0-9]{2}",
	                                   std::regex_constants::ECMAScript | std::regex_constants::icase));
}

std::string DateParser::parseDDMMYYYY(std::string dateString) {
	std::smatch matchResults;
	std::regex_match(dateString, matchResults,
	                 std::regex("([0-9]{2})-([0-9]{2})-([0-9]{4})",
	                            std::regex_constants::ECMAScript | std::regex_constants::icase));

	std::string day, month, year, hour, minute, formattedDateString;
	day = matchResults[1];
	month = matchResults[2];
	year = matchResults[3];
	hour = "00";
	minute = "00";
	formattedDateString = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":00.000";

	return formattedDateString;
}

std::string DateParser::parseDDMMYYYY_TTTT(std::string dateString) {
	std::smatch matchResults;
	std::regex_match(dateString, matchResults,
	                 std::regex("([0-9]{2})-([0-9]{2})-([0-9]{4}) ([0-9]{2})([0-9]{2})",
	                            std::regex_constants::ECMAScript | std::regex_constants::icase));

	std::string day, month, year, hour, minute, formattedDateString;
	day = matchResults[1];
	month = matchResults[2];
	year = matchResults[3];
	hour = matchResults[4];
	minute = matchResults[5];
	formattedDateString = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":00.000";

	return formattedDateString;
}
```
###### Parser\DateParser.h
``` h
#pragma once
#include <regex>
#include "../boost/date_time/posix_time/ptime.hpp"

class DateParser {
public:
	DateParser(void);
	static boost::posix_time::ptime parse(std::string dateString);

private:
	static bool isLocallySupportedDateFormat(std::string userInputDateString);
	static bool isBoostLibrarySupportedDateFormat(std::string userInputDateString);

	static std::string convertToFormattedDateString(std::string userInputDateString);
	static boost::posix_time::ptime getPtimeObject(std::string formattedDateString);
	static boost::posix_time::ptime getInvalidPtimeObject(void);

	static bool isDDMMYYYY_TTTT(std::string dateString);
	static bool isDDMMYY(std::string dateString);
	static std::string parseDDMMYYYY_TTTT(std::string dateString);
	static std::string parseDDMMYYYY(std::string dateString);
};
```
###### Parser\Parser.cpp
``` cpp
#include "Parser.h"

#include "CommandTokenisers\AddCommandTokeniser.h"
#include "CommandTokenisers\ConfigureCommandTokeniser.h"
#include "CommandTokenisers\CompleteCommandTokeniser.h"
#include "CommandTokenisers\DeleteCommandTokeniser.h"
#include "CommandTokenisers\DisplayCommandTokeniser.h"
#include "CommandTokenisers\ExportCommandTokeniser.h"
#include "CommandTokenisers\EditCommandTokeniser.h"
#include "CommandTokenisers\ImportCommandTokeniser.h"
#include "CommandTokenisers\RefreshCommandTokeniser.h"
#include "CommandTokenisers\SearchCommandTokeniser.h"
#include "CommandTokenisers\SortCommandTokeniser.h"
#include "CommandTokenisers\TagCommandTokeniser.h"
#include "CommandTokenisers\UndoCommandTokeniser.h"
#include "CommandTokenisers\UntagCommandTokeniser.h"

Parser::Parser(void) {
	_logger = Logger::getInstance();

	initialiseAllCommandTokenisers();
	initialiseInvalidCommandTokens();
}

void Parser::initialiseAllCommandTokenisers() {
	_commandTokenisers.push_back(new AddCommandTokeniser);
	_commandTokenisers.push_back(new ConfigureCommandTokeniser);
	_commandTokenisers.push_back(new CompleteCommandTokeniser);
	_commandTokenisers.push_back(new DeleteCommandTokeniser);
	_commandTokenisers.push_back(new DisplayCommandTokeniser);
	_commandTokenisers.push_back(new ExportCommandTokeniser);
	_commandTokenisers.push_back(new EditCommandTokeniser);
	_commandTokenisers.push_back(new ImportCommandTokeniser);
	_commandTokenisers.push_back(new RefreshCommandTokeniser);
	_commandTokenisers.push_back(new SearchCommandTokeniser);
	_commandTokenisers.push_back(new SortCommandTokeniser);
	_commandTokenisers.push_back(new TagCommandTokeniser);
	_commandTokenisers.push_back(new UndoCommandTokeniser);
	_commandTokenisers.push_back(new UntagCommandTokeniser);
}

void Parser::initialiseInvalidCommandTokens() {
	_invalidCommandTokens.setPrimaryCommand(CommandTokens::PrimaryCommandType::Invalid);
	_invalidCommandTokens.setSecondaryCommand(CommandTokens::SecondaryCommandType::None);
}

CommandTokens Parser::parse(std::string userInput) {
	_logger->logINFO("Parser::parse(std::string userInput):CommandTokens called with parameter userInput=\"" + userInput + "\"");

	CommandTokeniser* commandTokeniser = getCommandTokeniser(userInput);
	if (commandTokeniser == nullptr) {
		return _invalidCommandTokens;
	}
	return commandTokeniser->tokeniseUserInput(userInput);
}

CommandTokeniser* Parser::getCommandTokeniser(std::string userInput) {
	for (CommandTokeniser* commandTokeniser : _commandTokenisers) {
		if (commandTokeniser->canTokeniseUserInput(userInput)) {
			return commandTokeniser;
		}
	}
	return nullptr;
}
```
###### Parser\Parser.h
``` h
#pragma once
#include <regex>
#include "CommandTokens.h"
#include "CommandTokeniser.h"
#include "Logger\Logger.h"

// facade class to provide uniform way to assess the various concrete
// CommandTokeniser classes
class Parser {
public:
	Parser(void);
	CommandTokens parse(std::string userInput);

private:
	Logger* _logger;

	std::vector<CommandTokeniser*> _commandTokenisers;
	CommandTokens _invalidCommandTokens;

	void initialiseAllCommandTokenisers(void);
	void initialiseInvalidCommandTokens(void);
	CommandTokeniser* getCommandTokeniser(std::string userInput);
};
```
###### ParserTest\ParserTest.cpp
``` cpp
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ParserTest {
	TEST_CLASS(ParserTester) {
	public:
		Parser _parser;

		TEST_METHOD(unitTest_parser_TokeniseAddFromTo) {
			std::string testUserInput = "ADD activityTask FROM 2002-01-20 23:59:59.000 TO 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;

			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Add,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "activityTask",
			                                      "2002-01-20 23:59:59.000",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseAddBy) {
			std::string testUserInput = "ADD todoTask BY 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;

			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Add,
			                                      CommandTokens::SecondaryCommandType::By,
			                                      "todoTask",
			                                      "",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseAddFloating) {
			std::string testUserInput = "ADD floatingTask";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Add,
			                                      CommandTokens::SecondaryCommandType::Floating,
			                                      "floatingTask",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseComplete) {
			std::string testUserInput = "COMPLETE 11";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::MarkAsComplete,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      11);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseConfigureSaveLocation) {
			std::string testUserInput = "CONFIGURE SAVE LOCATION D:\\";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Configure,
			                                      CommandTokens::SecondaryCommandType::SaveLocation,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			expected.setOtherCommandParameter("D:\\");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteAll) {
			std::string testUserInput = "DELETE ALL";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::All,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteCompleted) {
			std::string testUserInput = "DELETE COMPLETED";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::Completed,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteIndex) {
			std::string testUserInput = "DELETE 3";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      3);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteBy) {
			std::string testUserInput = "DELETE BY 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::By,
			                                      "",
			                                      "",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteFromTo) {
			std::string testUserInput = "DELETE FROM 2002-01-20 23:59:59.000 TO 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDeleteFrom) {
			std::string testUserInput = "DELETE FROM 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Delete,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayAll) {
			std::string testUserInput = "DISPLAY ALL";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::All,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayActivity) {
			std::string testUserInput = "DISPLAY ACTIVITY";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayFloating) {
			std::string testUserInput = "DISPLAY FLOATING";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::Floating,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseDisplayTodo) {
			std::string testUserInput = "DISPLAY TODO";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Display,
			                                      CommandTokens::SecondaryCommandType::By,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseEditName) {
			std::string testUserInput = "EDIT NAME 3 newTaskName";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Edit,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "newTaskName",
			                                      "",
			                                      "",
			                                      3);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseEditStartDate) {
			std::string testUserInput = "EDIT START 5 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Edit,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      5);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseEditEndDate) {
			std::string testUserInput = "EDIT END 7 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Edit,
			                                      CommandTokens::SecondaryCommandType::End,
			                                      "",
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      7);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseExport) {
			std::string testUserInput = "EXPORT C:\\";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Export,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			expected.setOtherCommandParameter("C:\\");

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseImport) {
			std::string testUserInput = "IMPORT D:\\aRandomFile.txt";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Import,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			expected.setOtherCommandParameter("D:\\aRandomFile.txt");

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseRefresh) {
			std::string testUserInput = "REFRESH";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Refresh,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchName) {
			std::string testUserInput = "SEARCH NAME a Random Task";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "a Random Task",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchFromTo) {
			std::string testUserInput = "SEARCH FROM 2002-01-20 23:59:59.000 TO 2002-01-22 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::FromTo,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "2002-01-22 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchFreeSlot) {
			std::string testUserInput = "SEARCH FREE";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::FreeSlot,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchStartBefore) {
			std::string testUserInput = "SEARCH START BEFORE 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::StartBefore,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchStartAfter) {
			std::string testUserInput = "SEARCH START AFTER 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::StartAfter,
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchEndBefore) {
			std::string testUserInput = "SEARCH END BEFORE 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::EndBefore,
			                                      "",
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchEndAfter) {
			std::string testUserInput = "SEARCH END AFTER 2002-01-20 23:59:59.000";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::EndAfter,
			                                      "",
			                                      "",
			                                      "2002-01-20 23:59:59.000",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSearchTags) {
			std::string testUserInput = "SEARCH TAGS #123";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Search,
			                                      CommandTokens::SecondaryCommandType::Tags,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			std::vector<std::string> newTags;
			newTags.push_back("#123");
			expected.setTags(newTags);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortName) {
			std::string testUserInput = "SORT NAME";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Ascending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortNameDesc) {
			std::string testUserInput = "SORT NAME DESC";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Name,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Descending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortStart) {
			std::string testUserInput = "SORT START";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Ascending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortStartDesc) {
			std::string testUserInput = "SORT START DESC";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::Start,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Descending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortEnd) {
			std::string testUserInput = "SORT END";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::End,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Ascending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseSortEndDesc) {
			std::string testUserInput = "SORT END DESC";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Sort,
			                                      CommandTokens::SecondaryCommandType::End,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);
			
			expected.setOtherCommandParameter("Descending");
			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseTag) {
			std::string testUserInput = "TAG 19 #123 #abc";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Tag,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      19);
			std::vector<std::string> newTags;
			newTags.push_back("#123");
			newTags.push_back("#abc");
			expected.setTags(newTags);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseUndo) {
			std::string testUserInput = "UNDO";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Undo,
			                                      CommandTokens::SecondaryCommandType::None,
			                                      "",
			                                      "",
			                                      "",
			                                      -1);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_TokeniseUntag) {
			std::string testUserInput = "UNTAG 23 #12c #ab3";
			CommandTokens actual, expected;
			actual = _parser.parse(testUserInput);
			expected = buildExpectedCommandTokens(CommandTokens::PrimaryCommandType::Untag,
			                                      CommandTokens::SecondaryCommandType::Index,
			                                      "",
			                                      "",
			                                      "",
			                                      23);
			std::vector<std::string> newTags;
			newTags.push_back("#12c");
			newTags.push_back("#ab3");
			expected.setTags(newTags);

			compareCommandTokens(expected, actual);
		}

		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH) {
			std::string testUserInputDate = "13-05-1999 1320";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("1999-05-13 13:20:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY) {
			std::string testUserInputDate = "13-05-1999";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("1999-05-13 00:00:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		// upper boundary case for valid date range partition
		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH_MaxRange) {
			std::string testUserInputDate = "31-12-9999 2359";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("9999-12-31 23:59:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		// lower boundary case for valid date range partition
		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH_MinRange) {
			std::string testUserInputDate = "01-01-1400 0000";

			boost::posix_time::ptime expected(boost::posix_time::time_from_string("1400-01-01 00:00:00.000"));
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		// edge cases partition: dates that are invalid because of non-uniform length of months
		TEST_METHOD(unitTest_parser_DateParser_DD_MM_YYYY_HHHH_InvalidDate) {
			std::string testUserInputDate = "29-02-1999 1345";

			boost::posix_time::ptime expected;
			boost::posix_time::ptime actual;
			actual = DateParser::parse(testUserInputDate);

			Assert::IsTrue(expected == actual);
		}

		CommandTokens buildExpectedCommandTokens(CommandTokens::PrimaryCommandType primaryCommandType,
		                                         CommandTokens::SecondaryCommandType secondaryCommandType,
		                                         std::string taskName,
		                                         std::string startDate,
		                                         std::string endDate,
		                                         int index) {

			CommandTokens expected;

			expected.setPrimaryCommand(primaryCommandType);
			expected.setSecondaryCommand(secondaryCommandType);
			expected.setTaskName(taskName);
			expected.setIndex(index);

			// if an empty string is passed in, the command has no startDate
			if (startDate == "") {
				boost::posix_time::ptime notAPtime; // default constructor gives a not_a_date_time object
				expected.setStartDateTime(notAPtime);
			} else {
				boost::posix_time::ptime expectedStartDate(boost::posix_time::time_from_string(startDate));
				expected.setStartDateTime(expectedStartDate);
			}

			// if an empty string is passed in, the command has no endDate
			if (endDate == "") {
				boost::posix_time::ptime notAPtime; // default constructor gives a not_a_date_time object
				expected.setEndDateTime(notAPtime);
			} else {
				boost::posix_time::ptime expectedEndDate(boost::posix_time::time_from_string(endDate));
				expected.setEndDateTime(expectedEndDate);
			}

			return expected;
		}

		void compareCommandTokens(CommandTokens expected, CommandTokens actual) {

			Assert::AreEqual(int(expected.getPrimaryCommand()), int(actual.getPrimaryCommand()));
			Assert::AreEqual(int(expected.getSecondaryCommand()), int(actual.getSecondaryCommand()));
			Assert::AreEqual(expected.getTaskName(), actual.getTaskName());
			Assert::IsTrue(expected.getStartDateTime() == actual.getStartDateTime());
			Assert::IsTrue(expected.getEndDateTime() == actual.getEndDateTime());
			Assert::AreEqual(expected.getIndex(), actual.getIndex());
			Assert::AreEqual(expected.getOtherCommandParameter(), actual.getOtherCommandParameter());

			std::vector<std::string> expectedTags, actualTags;
			expectedTags = expected.getTags();
			actualTags = actual.getTags();

			// checks if tags are both empty, else iterates through each element and assert equality
			Assert::AreEqual(expectedTags.empty(), actualTags.empty());
			if (!expectedTags.empty()) {
				for (unsigned i = 0; i < expectedTags.size(); i++) {
					Assert::AreEqual(expectedTags.at(i), actualTags.at(i));
				}
			}
		}
	};
}
```
