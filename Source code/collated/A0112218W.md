# A0112218W
###### Logic\Command.cpp
``` cpp

#include <assert.h>
#include <limits>
#include "Command.h"

COMMAND_CREATION_EXCEPTION::COMMAND_CREATION_EXCEPTION (const char* e) : std::exception(e) {
}

COMMAND_CREATION_EXCEPTION::COMMAND_CREATION_EXCEPTION (std::string errorMessage) : std::exception(errorMessage.c_str()){
}

COMMAND_EXECUTION_EXCEPTION::COMMAND_EXECUTION_EXCEPTION(const char* e) : std::exception(e) {
}

COMMAND_EXECUTION_EXCEPTION::COMMAND_EXECUTION_EXCEPTION(std::string errorMessage) : std::exception(errorMessage.c_str()) {
}

Command::Command(CommandTokens::PrimaryCommandType type) {
	_type1 = type;
	_statusExecuted = false;
	_runTimeStorageExecuted = NULL;
}

CommandTokens::PrimaryCommandType Command::getPrimaryCommandType() {
	return _type1;
}

CommandTokens::SecondaryCommandType Command::getSecondaryCommandType() {
	return _type2;
}

bool Command::isValid() {
	if (_type1 == CommandTokens::PrimaryCommandType::Invalid) {
		return false;
	} else {
		return true;
	}
}

bool Command::isExecuted() {
	return _statusExecuted;
}

RunTimeStorage* Command::getRunTimeStorageExecuted() {
	return _runTimeStorageExecuted;
}

```
###### Logic\Command.h
``` h
#pragma once

#include <cstdio>
#include "RunTimeStorage.h"
using namespace API;

/**
 *	Exception to be thrown for all exception in constructor.
 *	Usage is the same as std::exception.
 *  Support constructor with std::string
 */
class COMMAND_CREATION_EXCEPTION : public std::exception {
public:
	/**
	 *	Constructor with C-string
	 */
	explicit COMMAND_CREATION_EXCEPTION (const char* errorMessage);

	/**
	 *	Constructor with std::string
	 */
	explicit COMMAND_CREATION_EXCEPTION (std::string errorMessage);
};

/**
 *	Exception to be thrown for all exception during execution of command.
 *	Usage is the same as std::exception.
 *	Support constructor with std::string.
 */
class COMMAND_EXECUTION_EXCEPTION : public std::exception {
public:
	/**
	 *	Constructor with C-string
	 */
	explicit COMMAND_EXECUTION_EXCEPTION(const char* errorMessage);

	/**
	 *	Constructor with std::string
	 */
	explicit COMMAND_EXECUTION_EXCEPTION(std::string errorMessage);
};

/**
 *	Super class for all Command sub-classes.
 *	All command sub class inherit this class need to define execute(RunTimeStorage*), canUndo() and undo()
 *	canUndo() is a method determine whether the command can be undo or not by returning a boolean value.
 *	If canUndo() return false, then assert (false) in its undo() method to ensure undo can never be called.
 */
class Command {
protected:

	CommandTokens::PrimaryCommandType _type1;
	CommandTokens::SecondaryCommandType _type2;
	
	/**
	 *	Needed for undo
	 *	If it is NULL, undo cannot be performed. 
	 *  assert(_runTimeStorageExecuted != NULL) is needed for all undo method.
	 */
	RunTimeStorage* _runTimeStorageExecuted;

	/**
	 *	Flag variable about whether the command object have been executed before.
	 *  At the end of all execute method, it should be set to true when it is executed successfully.
	 *	Undo method need to assert this variable is true before it can proceed to execution.
	 */
	bool _statusExecuted;

	void checkIsValidForExecute(RunTimeStorage* runTimeStorage) {
		assert(runTimeStorage != NULL);
		assert(!_statusExecuted);
	}

	void checkIsValidForUndo() {
		assert(_runTimeStorageExecuted!=NULL);
		assert(_statusExecuted);
	}

	void postExecutionAction(RunTimeStorage* runTimeStorage) {
		_statusExecuted = true;
		_runTimeStorageExecuted = runTimeStorage;
	}

	void postUndoAction() {
		_statusExecuted = false;
		_runTimeStorageExecuted = NULL;
	}

public:
	/**
	 *	Constructor 
	 *  @param type PrimaryCommandType which correspond to the sub-classes inherited from it.
	 */
	Command(CommandTokens::PrimaryCommandType type);

	/**
	 *	Getter function for PrimaryCommandType of a Command.
	 */
	CommandTokens::PrimaryCommandType getPrimaryCommandType(void);

	/**
	 *	Getter function for SecondaryCommandType of a Command.
	 */
	CommandTokens::SecondaryCommandType getSecondaryCommandType(void);

	/**
	 *	Getter function for RunTimeStorage* the Command have executed on.
	 */
	RunTimeStorage* getRunTimeStorageExecuted();

	/**
	 *	Identifier method whether the Command object is valid for execution or not.
	 */
	bool isValid(void);

	/**
	 *	Identifier method whether the Command object have been executed before or not.
	 */
	bool isExecuted(void);

	/**
	 *	Execution method of a command. Need to be implemented by all sub classes.
	 *	@param runTimeStorage The RunTimeStorage object that the Command are supposed to give instruction to.
	 *	@return UIFeedback An object which contains a vector of tasks to display and a feedback message
	 */
	virtual UIFeedback execute(RunTimeStorage* runTimeStorage) = 0;

	/**
	 *	Undo method of a command. Need to be implemented by all sub classes.
	 *	If the command is not undoable, implement undo method of that sub class as follows: \n
	 *	\code {.cpp}
	 *  UIFeedback undo(void) {
	 *		assert (false); //To ensure it is never called.
	 *		return UIFeedback(); //To return a dummy UIFeedback so that it is compilable.
	 *	}
	 *	\endcode
	 */
	virtual UIFeedback undo(void) = 0;

	/**
	 *	Identifier method about whether the command is undoable or not.
	 *	Undo method should only be called if and only if this method return true
	 */
	virtual bool canUndo(void) = 0;

	/**
	 *	destructor
	 */
	~Command() {}

};
```
###### Logic\CommandCreator.cpp
``` cpp

#include "CommandCreator.h"

INVALID_COMMAND_EXCEPTION::INVALID_COMMAND_EXCEPTION(std::string message) : std::exception(message.c_str()){
}

Command* CommandCreator::processByPrimaryCommandType(CommandTokens commandTokens) {
	CommandTokens::PrimaryCommandType command1 = commandTokens.getPrimaryCommand();
	Command* returnCommand = NULL;
	try {
		switch (command1) {
		case CommandTokens::PrimaryCommandType::Add:
			returnCommand = processAddCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Configure:
			returnCommand = processConfigureCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Delete:
			returnCommand = processDeleteCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Display:
			returnCommand = processDisplayCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Edit:
			returnCommand = processEditCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::MarkAsComplete:
			returnCommand = processSetCompleteCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Export:
			returnCommand = processExportCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Import:
			returnCommand = processImportCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Refresh:
			returnCommand = processRefreshCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Tag:
			returnCommand = processTagCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Untag:
			returnCommand = processUntagCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Search:
			returnCommand = processSearchCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Sort:
			returnCommand = processSortCommand(commandTokens);
			break;
		case CommandTokens::PrimaryCommandType::Invalid:
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
			break;
		default:
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw e;
	} catch (COMMAND_CREATION_EXCEPTION e) {
		throw e;
	}

	return returnCommand;
}

AddCommand* CommandCreator::processAddCommand(CommandTokens commandTokens) {
	AddCommand* returnCommand = NULL;
	CommandTokens::SecondaryCommandType command2 = commandTokens.getSecondaryCommand();
	Task task;
	std::vector<std::string> tags = commandTokens.getTags();

	std::string taskName = commandTokens.getTaskName();
	try {
		switch (command2) {
		case CommandTokens::SecondaryCommandType::Floating:
			task = Task(taskName);
			for (size_t i = 0 ; i < tags.size() ; ++i) {
				task.addTag(tags[i]);
			}
			returnCommand = new AddCommand(CommandTokens::SecondaryCommandType::Floating,task);
			break;
		case CommandTokens::SecondaryCommandType::By:
			task = Task(taskName,commandTokens.getEndDateTime());
			for (size_t i = 0 ; i < tags.size() ; ++i) {
				task.addTag(tags[i]);
			}
			returnCommand = new AddCommand(CommandTokens::SecondaryCommandType::By,task);
			break;
		case CommandTokens::SecondaryCommandType::FromTo:
			task = Task(taskName,commandTokens.getStartDateTime(), commandTokens.getEndDateTime());
			for (size_t i = 0 ; i < tags.size() ; ++i) {
				task.addTag(tags[i]);
			}
			returnCommand = new AddCommand(CommandTokens::SecondaryCommandType::FromTo, task);
			break;
		default:
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
	} catch (TASK_EXCEPTION e) {
		throw INVALID_COMMAND_EXCEPTION(e.what());
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw e;
	}
	return returnCommand;
}

ConfigureSaveLocationCommand* CommandCreator::processConfigureCommand(CommandTokens commandTokens) {
	ConfigureSaveLocationCommand* returnCommand = NULL;
	std::string savePath = commandTokens.getOtherCommandParameter();
	returnCommand = new ConfigureSaveLocationCommand(savePath);
	return returnCommand;
}

DeleteCommand* CommandCreator::processDeleteCommand(CommandTokens commandTokens) {
	DeleteCommand* returnCommand = NULL;
	CommandTokens::SecondaryCommandType command2 = commandTokens.getSecondaryCommand();

	ptime startDateTime = commandTokens.getStartDateTime();
	ptime endDateTime = commandTokens.getEndDateTime();
	try{
		switch (command2) {
		case CommandTokens::SecondaryCommandType::Index:
			returnCommand = processDeleteIndexCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::All:
			returnCommand = processDeleteAllCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::By:
			returnCommand = processDeleteBeforeCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::FromTo:
			returnCommand = processDeleteFromToCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::Completed:
			returnCommand = processDeleteCompleteCommand(commandTokens);
			break;
		default:
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw e;
	}
	return returnCommand;
}

DeleteIndexCommand* CommandCreator::processDeleteIndexCommand(CommandTokens commandTokens) {
	DeleteIndexCommand* returnCommand = NULL;
	int index = commandTokens.getIndex(); 
	if (index < 1) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
	} else {
		returnCommand = new DeleteIndexCommand(index);
	}
	return returnCommand;
}

DeleteBeforeCommand* CommandCreator::processDeleteBeforeCommand(CommandTokens commandTokens) {
	DeleteBeforeCommand* returnCommand = NULL;
	ptime endDateTime = commandTokens.getEndDateTime();
	if (endDateTime.is_special()) {
		throw INVALID_COMMAND_EXCEPTION (MESSAGE_INVALID_DATE_TIME);
	}
	returnCommand = new DeleteBeforeCommand(endDateTime);
	return returnCommand;
}

DeleteFromToCommand* CommandCreator::processDeleteFromToCommand(CommandTokens commandTokens) {
	DeleteFromToCommand* returnCommand = NULL;
	ptime startDateTime = commandTokens.getStartDateTime();
	ptime endDateTime = commandTokens.getEndDateTime();
	if (startDateTime.is_special() || endDateTime.is_special()) {
		throw INVALID_COMMAND_EXCEPTION (MESSAGE_INVALID_DATE_TIME);
	} else if (startDateTime > endDateTime) {
		throw INVALID_COMMAND_EXCEPTION (MESSAGE_END_LESS_THAN_START);
	}
	returnCommand = new DeleteFromToCommand(startDateTime, endDateTime);
	return returnCommand;
}

DeleteAllCommand* CommandCreator::processDeleteAllCommand(CommandTokens commandTokens) {
	DeleteAllCommand* returnCommand = new DeleteAllCommand();
	return returnCommand;
}

DeleteCompleteCommand* CommandCreator::processDeleteCompleteCommand(CommandTokens commandTokens) {
	DeleteCompleteCommand* returnCommand = new DeleteCompleteCommand();
	return returnCommand;
}

DisplayCommand* CommandCreator::processDisplayCommand(CommandTokens commandTokens) {
	DisplayCommand* returnCommand = NULL;
	CommandTokens::SecondaryCommandType type2 = commandTokens.getSecondaryCommand();
	switch (type2) {
	case CommandTokens::SecondaryCommandType::All:
		returnCommand = new DisplayCommand(Display_Type::displayAll);
		break;
	case CommandTokens::SecondaryCommandType::Floating:
		returnCommand = new DisplayCommand(Display_Type::displayFloat);
		break;
	case CommandTokens::SecondaryCommandType::By:
		returnCommand = new DisplayCommand(Display_Type::displayTodo);
		break;
	case CommandTokens::SecondaryCommandType::FromTo:
		returnCommand = new DisplayCommand(Display_Type::displayTimed);
		break;
	default:
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
	}
	return returnCommand;
}

EditCommand* CommandCreator::processEditCommand(CommandTokens commandTokens) {
	EditCommand* returnCommand = NULL;
	CommandTokens::SecondaryCommandType command2 = commandTokens.getSecondaryCommand();

	try {
		switch (command2) {
		case CommandTokens::SecondaryCommandType::Name:
			returnCommand = processEditNameCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::Start:
			returnCommand = processEditStartCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::End:
			returnCommand = processEditEndCommand(commandTokens);
			break;
		default:
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw e;
	}
	return returnCommand;
}

EditNameCommand* CommandCreator::processEditNameCommand(CommandTokens commandTokens) {
	EditNameCommand* returnCommand = NULL;
	int index = commandTokens.getIndex();
	if (index < 1) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
	}
	std::string newName = commandTokens.getTaskName();
	if (newName.empty()) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_EDIT_NAME_EMPTY);
	} else {
		returnCommand = new EditNameCommand(index, newName);
	}
	return returnCommand;
}

EditStartCommand* CommandCreator::processEditStartCommand(CommandTokens commandTokens) {
	EditStartCommand* returnCommand = NULL;
	int index = commandTokens.getIndex();
	if (index < 1) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
	}
	ptime newStart = commandTokens.getStartDateTime();
	returnCommand = new EditStartCommand(index, newStart);
	return returnCommand;
}

EditEndCommand* CommandCreator::processEditEndCommand(CommandTokens commandTokens) {
	EditEndCommand* returnCommand = NULL;
	int index = commandTokens.getIndex();
	if (index < 1) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
	}
	ptime newEnd = commandTokens.getEndDateTime();
	returnCommand = new EditEndCommand(index, newEnd);
	return returnCommand;
}

SetCompleteCommand* CommandCreator::processSetCompleteCommand(CommandTokens commandTokens) {
	SetCompleteCommand* returnCommand = NULL;
	CommandTokens::SecondaryCommandType command2 = commandTokens.getSecondaryCommand();
	int index = commandTokens.getIndex();
	switch (command2) {
	case CommandTokens::SecondaryCommandType::Index:
		if (index < 1) {
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
		} else {
			returnCommand = new SetCompleteCommand(index);
		}
		break;
	default:
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
	}
	return returnCommand;
}

ExportCommand* CommandCreator::processExportCommand(CommandTokens commandTokens) {
	std::string filePath = commandTokens.getOtherCommandParameter();
	ExportCommand* returnCommand = new ExportCommand(filePath);
	return returnCommand;
}

ImportCommand* CommandCreator::processImportCommand(CommandTokens commandTokens) {
	std::string filePath = commandTokens.getOtherCommandParameter();
	ImportCommand* returnCommand = new ImportCommand(filePath);
	return returnCommand;
}

RefreshCommand* CommandCreator::processRefreshCommand(CommandTokens commandTokens) {
	RefreshCommand* returnCommand = new RefreshCommand();
	return returnCommand;
}

TagCommand* CommandCreator::processTagCommand(CommandTokens commandTokens) {
	int index = commandTokens.getIndex();
	if (index < 1) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
	}
	std::vector<std::string> tags = commandTokens.getTags();
	TagCommand* returnCommand = new TagCommand(index, tags);
	return returnCommand;
}

UntagCommand* CommandCreator::processUntagCommand(CommandTokens commandTokens) {
	int index = commandTokens.getIndex();
	if (index < 1) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_NON_POSITIVE_INDEX);
	}
	std::vector<std::string> untags = commandTokens.getTags();
	UntagCommand* returnCommand = new UntagCommand(index, untags);
	return returnCommand;
}

SearchCommand* CommandCreator::processSearchCommand(CommandTokens commandTokens) {
	CommandTokens::SecondaryCommandType type2 = commandTokens.getSecondaryCommand();
	SearchCommand* returnCommand;
	try {
		switch (type2) {
		case CommandTokens::SecondaryCommandType::StartBefore:
			returnCommand = processSearchStartBeforeCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::StartAfter:
			returnCommand = processSearchStartAfterCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::EndBefore:
			returnCommand = processSearchEndBeforeCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::EndAfter:
			returnCommand = processSearchEndAfterCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::Tags:
			returnCommand = processSearchTagsCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::Name:
			returnCommand = processSearchNameCommand(commandTokens);
			break;
		case CommandTokens::SecondaryCommandType::FromTo:
			returnCommand = processSearchFromToCommand(commandTokens);
			break;
		default:
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw e;
	}

	return returnCommand;
}

SearchStartBeforeCommand* CommandCreator::processSearchStartBeforeCommand(CommandTokens commandTokens) {
	SearchStartBeforeCommand* returnCommand;
	ptime start = commandTokens.getStartDateTime();
	if (start.is_special()) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_DATE_TIME);
	}
	returnCommand = new SearchStartBeforeCommand(start);
	return returnCommand;
}

SearchStartAfterCommand* CommandCreator::processSearchStartAfterCommand(CommandTokens commandTokens) {
	SearchStartAfterCommand* returnCommand;
	ptime start = commandTokens.getStartDateTime();
	if (start.is_special()) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_DATE_TIME);
	}
	returnCommand = new SearchStartAfterCommand(start);
	return returnCommand;
}

SearchEndBeforeCommand* CommandCreator::processSearchEndBeforeCommand(CommandTokens commandTokens) {
	SearchEndBeforeCommand* returnCommand;
	ptime end = commandTokens.getEndDateTime();
	if (end.is_special()) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_DATE_TIME);
	}
	returnCommand = new SearchEndBeforeCommand(end);
	return returnCommand;
}

SearchEndAfterCommand* CommandCreator::processSearchEndAfterCommand(CommandTokens commandTokens) {
	SearchEndAfterCommand* returnCommand;
	ptime end = commandTokens.getEndDateTime();
	if (end.is_special()) {
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_DATE_TIME);
	}
	returnCommand = new SearchEndAfterCommand(end);
	return returnCommand;
}

SearchTagsCommand* CommandCreator::processSearchTagsCommand(CommandTokens commandTokens) {
	SearchTagsCommand* returnCommand;
	std::vector<std::string> tags = commandTokens.getTags();
	returnCommand = new SearchTagsCommand(tags);
	return returnCommand;
}

SearchNameCommand* CommandCreator::processSearchNameCommand(CommandTokens commandTokens) {
	SearchNameCommand* returnCommand;
	std::string searchString = commandTokens.getTaskName();
	returnCommand = new SearchNameCommand(searchString);
	return returnCommand;
}

SearchFromToCommand* CommandCreator::processSearchFromToCommand(CommandTokens commandTokens) {
	SearchFromToCommand* returnCommand;
	ptime start = commandTokens.getStartDateTime();
	ptime end = commandTokens.getEndDateTime();
	returnCommand = new SearchFromToCommand(start,end);
	return returnCommand;
}

SortCommand* CommandCreator::processSortCommand(CommandTokens commandTokens) {
	SortCommand* returnCommand;
	CommandTokens::SecondaryCommandType type2 = commandTokens.getSecondaryCommand();
	std::string sortOrder = commandTokens.getOtherCommandParameter();
	switch (type2) {
	case CommandTokens::SecondaryCommandType::Name:
		if (sortOrder == ASCENDING_ORDER) {
			returnCommand = new SortCommand(Sort_Type::sortByName);
		} else if (sortOrder == DESCENDING_ORDER) {
			returnCommand = new SortCommand(Sort_Type::sortByNameDesc);
		} else {
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
		break;
	case CommandTokens::SecondaryCommandType::Start:
		if (sortOrder == ASCENDING_ORDER) {
			returnCommand = new SortCommand(Sort_Type::sortByStart);
		} else if (sortOrder == DESCENDING_ORDER) {
			returnCommand = new SortCommand(Sort_Type::sortByStartDesc);
		} else {
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
		break;
	case CommandTokens::SecondaryCommandType::End:
		if (sortOrder == ASCENDING_ORDER) {
			returnCommand = new SortCommand(Sort_Type::sortByEnd);
		} else if (sortOrder == DESCENDING_ORDER) {
			returnCommand = new SortCommand(Sort_Type::sortByEndDesc);
		} else {
			throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
		}
		break;
	default:
		throw INVALID_COMMAND_EXCEPTION(MESSAGE_INVALID_COMMAND);
	}
	return returnCommand;
}

CommandCreator::CommandCreator() {
}

Command* CommandCreator::process(CommandTokens commandTokens) {
	Command* returnCommand;
	try {
		returnCommand = processByPrimaryCommandType(commandTokens);
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw e;
	} catch (COMMAND_CREATION_EXCEPTION e) {
		throw e;
	}
	return returnCommand;
}
```
###### Logic\CommandCreator.h
``` h
#pragma once

#include <cstdio>
#include "..\Parser\Parser.h"
#include "..\Logger\Logger.h"
#include "CommandHeader.h"

const std::string MESSAGE_INVALID_COMMAND = "Invalid Command. No change is made.";
const std::string MESSAGE_NON_POSITIVE_INDEX = "Only positive index is allowed. No change is made.";
const std::string MESSAGE_INVALID_DATE_TIME = "Invalid date time is found. Please use the following format for date time : dd-mm-yyyy hhmm";

const std::string ASCENDING_ORDER = "Ascending";
const std::string DESCENDING_ORDER = "Descending";

class INVALID_COMMAND_EXCEPTION : public std::exception{
public:
	explicit INVALID_COMMAND_EXCEPTION(std::string message);
};

class CommandCreator {
private:
	static Logger* logger;

	static Command* processByPrimaryCommandType(CommandTokens);

	static AddCommand* processAddCommand(CommandTokens);

	static ConfigureSaveLocationCommand* processConfigureCommand(CommandTokens);

	static DeleteCommand* processDeleteCommand(CommandTokens);
	static DeleteIndexCommand* processDeleteIndexCommand(CommandTokens);
	static DeleteBeforeCommand* processDeleteBeforeCommand(CommandTokens);
	static DeleteFromToCommand* processDeleteFromToCommand(CommandTokens);
	static DeleteAllCommand* processDeleteAllCommand(CommandTokens);
	static DeleteCompleteCommand* processDeleteCompleteCommand(CommandTokens);

	static DisplayCommand* processDisplayCommand(CommandTokens);

	static EditCommand* processEditCommand(CommandTokens);
	static EditNameCommand* processEditNameCommand(CommandTokens);
	static EditStartCommand* processEditStartCommand(CommandTokens);
	static EditEndCommand* processEditEndCommand(CommandTokens);

	static ExportCommand* processExportCommand(CommandTokens);

	static ImportCommand* processImportCommand(CommandTokens);

	static RefreshCommand* processRefreshCommand(CommandTokens);

	static SearchCommand* processSearchCommand(CommandTokens);
	static SearchStartBeforeCommand* processSearchStartBeforeCommand(CommandTokens);
	static SearchStartAfterCommand* processSearchStartAfterCommand(CommandTokens);
	static SearchEndBeforeCommand* processSearchEndBeforeCommand(CommandTokens);
	static SearchEndAfterCommand* processSearchEndAfterCommand(CommandTokens);
	static SearchTagsCommand* processSearchTagsCommand(CommandTokens);
	static SearchNameCommand* processSearchNameCommand(CommandTokens);
	static SearchFromToCommand* processSearchFromToCommand(CommandTokens);

	static SetCompleteCommand* processSetCompleteCommand(CommandTokens);

	static SortCommand* processSortCommand(CommandTokens);

	static TagCommand* processTagCommand(CommandTokens);

	static UntagCommand* processUntagCommand(CommandTokens);
public:
	CommandCreator();
	Command* process(CommandTokens);

	//Methods below are for unit testing which allows private method to be called when TESTMODE is defined

#ifdef TESTMODE

	AddCommand* testProcessAddCommand(CommandTokens commandTokens) {
		return processAddCommand(commandTokens);
	}

	DeleteIndexCommand* testProcessDeleteIndexCommand(CommandTokens commandTokens) {
		return processDeleteIndexCommand(commandTokens);
	}

	DeleteBeforeCommand* testProcessDeleteBeforeCommand(CommandTokens commandTokens) {
		return processDeleteBeforeCommand(commandTokens);
	}

	DeleteFromToCommand* testProcessDeleteFromToCommand(CommandTokens commandTokens) {
		return processDeleteFromToCommand(commandTokens);
	}

	DeleteAllCommand* testProcessDeleteAllCommand(CommandTokens commandTokens) {
		return processDeleteAllCommand(commandTokens);
	}

	EditCommand* testProcessEditCommand(CommandTokens commandTokens) {
		return processEditCommand(commandTokens);
	}

	EditNameCommand* testProcessEditNameCommand(CommandTokens commandTokens) {
		return processEditNameCommand(commandTokens);
	}

	EditStartCommand* testProcessEditStartCommand(CommandTokens commandTokens) {
		return processEditStartCommand(commandTokens);
	}

	EditEndCommand* testProcessEditEndCommand(CommandTokens commandTokens) {
		return processEditEndCommand(commandTokens);
	}

#endif
};
```
###### Logic\CommandExecutor.cpp
``` cpp

#include "CommandExecutor.h"

UNDO_EXCEPTION::UNDO_EXCEPTION(const char* errorMessage) : std::exception(errorMessage) {
}

UNDO_EXCEPTION::UNDO_EXCEPTION(std::string errorMessage) : std::exception(errorMessage.c_str()) {
}

CommandExecutor::CommandExecutor() {
	_runTimeStorage = new RunTimeStorage();
}

UIFeedback CommandExecutor::execute(Command* command) {
	UIFeedback feedback;
	try {
		feedback = command -> execute (_runTimeStorage);
	} catch (COMMAND_EXECUTION_EXCEPTION e) {
		throw e;
	} 

	if (command -> isExecuted() && command->canUndo()) {
		_commandExecutedAndUndoable.push(command);
	} else {
		delete command;
	}

	_runTimeStorage->saveToFile();
	return feedback;
}

UIFeedback CommandExecutor::undo() {
	UIFeedback feedback;
	if (_commandExecutedAndUndoable.empty()) {
		throw UNDO_EXCEPTION(MESSAGE_UNDO_EMPTY);
	} 

	Command* command = _commandExecutedAndUndoable.top();

	try {
		_commandExecutedAndUndoable.pop();
		assert(command->canUndo());
		feedback = command -> undo();
	} catch (std::exception e) {
		throw e;
	}

	delete command;

	_runTimeStorage->saveToFile();
	return feedback;
}

CommandExecutor::~CommandExecutor() {
	while (!_commandExecutedAndUndoable.empty()) {
		delete _commandExecutedAndUndoable.top();
		_commandExecutedAndUndoable.top() = NULL;
		_commandExecutedAndUndoable.pop();
	}
	delete _runTimeStorage;
	_runTimeStorage = NULL;
}
```
###### Logic\CommandExecutor.h
``` h
#pragma once

#include <stack>
#include "CommandHeader.h"
#include "RunTimeStorage.h"

using namespace API;

const std::string MESSAGE_UNDO_EMPTY = "There is no task available to undo. No change is made.";

class UNDO_EXCEPTION : public std::exception {
public:
	explicit UNDO_EXCEPTION(const char* errorMessage);

	explicit UNDO_EXCEPTION(std::string errorMessage);
};

class CommandExecutor {
private:
	std::stack<Command*> _commandExecutedAndUndoable;
	RunTimeStorage* _runTimeStorage;

public:
	CommandExecutor();

	UIFeedback execute(Command* command);
	UIFeedback undo();

	virtual ~CommandExecutor();
};
```
###### Logic\CommandHeader.h
``` h

#pragma once

//A single header file to include all command classes.

#include "Command_Add.h"
#include "Command_Configure.h"
#include "Command_Delete.h"
#include "Command_Display.h"
#include "Command_Edit.h"
#include "Command_Export.h"
#include "Command_Import.h"
#include "Command_Refresh.h"
#include "Command_Search.h"
#include "Command_Set.h"
#include "Command_Sort.h"
#include "Command_Tag.h"
#include "Command_Untag.h"
```
###### Logic\Command_Add.cpp
``` cpp

#include "Command_Add.h"

AddCommand::AddCommand (CommandTokens::SecondaryCommandType type2, Task task) : Command(CommandTokens::PrimaryCommandType::Add) {
	_type2 = type2;
	_task = task;
}

UIFeedback AddCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);

	UIFeedback feedback;
	try {
		runTimeStorage->add(_task);
		std::string taskText = _task.getTaskText();
		std::string startDateTime = boost::posix_time::to_simple_string(_task.getStartDateTime());
		std::string endDateTime = boost::posix_time::to_simple_string(_task.getEndDateTime());
		char buffer[255];
		sprintf_s(buffer, MESSAGE_ADD_SUCCESS.c_str(), taskText.c_str(), startDateTime.c_str(), endDateTime.c_str());
		std::string feedbackMessage(buffer);
		feedback = UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
		postExecutionAction(runTimeStorage);
	} catch (DUPLICATE_TASK_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}
	return feedback;
}

UIFeedback AddCommand::undo() {
	checkIsValidForUndo();
	_runTimeStorageExecuted -> removeLastEntry();
	std::vector<Task>& tasksToDisplay = _runTimeStorageExecuted->refreshTasksToDisplay();
	postUndoAction();
	return UIFeedback(tasksToDisplay, MESSAGE_UNDO_ADD);
}

bool AddCommand::canUndo() {
	return true;
}

AddCommand::~AddCommand(void) {	
}
```
###### Logic\Command_Add.h
``` h
#pragma once
#include "Command.h"

//Feedback message for different add operation result
const std::string MESSAGE_ADD_SUCCESS = "\"%s\" have been added succesfully.\nStart Date Time: %s\nEnd Date Time: %s"; 
const std::string MESSAGE_ADD_EMPTY = "Task text cannot be empty. New task is not added.";

//Feedback message when add operation is undoed
const std::string MESSAGE_UNDO_ADD = "Previous add operation is undoed succesfully";

/**
 *	Command sub class responsible for adding task
 */
class AddCommand: public Command {
private:
	/**
	 *	Task to be added.
	 */
	Task _task;
public:
	/**
	 *	Constructor
	 *	@param type2 SecondaryCommandType which corresponding to the type of task added.
	 *	@param task Task to be added.
	 */
	AddCommand (CommandTokens::SecondaryCommandType type2, Task task);

	/**
	 *	Execution method of AddCommand.
	 *	_task will be added to RunTimeStorage* provided.
	 */
	UIFeedback execute(RunTimeStorage*);

	/**
	 *	Undo method of AddCommand.
	 *	Will remove the task added to RunTimeStorage.
	 *
	 */
	UIFeedback undo(void);

	/**
	 *	Return true all the time.
	 */
	bool canUndo();

	virtual ~AddCommand(void);

#ifdef TESTMODE

	Task getTask() {
		return _task;
	}

#endif
};
```
###### Logic\Command_Configure.h
``` h

#pragma once

#include "Command.h"

const std::string MESSAGE_CONFIG_SAVE_PATH_SUCCESS = "Default save path have been changed to %s";
const std::string MESSAGE_CONFIG_SAVE_PATH_UNDO = "Default save path have been reverted back.";

/**
 *	Command sub class responsible to configure default save location of Swiftask
 */
class ConfigureSaveLocationCommand : public Command {
private:
	/**
	 *	New save path to overwrite the current default save path
	 */
	std::string _newSavePath;

	/**
	 *	Old save path to overwrite the current default save path during undo
	 */
	std::string _oldSavePath;
public:
	/**
	 *	Constructor
	 *	@param savePath Save path that want to be set as default save path
	 */
	ConfigureSaveLocationCommand(std::string savePath);

	/**
	 *	Execution method of ConfigureSaveLocationCommand
	 *	Current default save path will be overwrite by the new one.
	 */
	UIFeedback Command::execute(RunTimeStorage*);

	/**
	 *	Undo method of ConfigureSaveLocationCommand
	 *	Revert the default save path to the previous one.
	 */
	UIFeedback Command::undo();

	/**
	 *	Return true all the time
	 */
	bool Command::canUndo();

	/**
	 *	Destructor
	 */
	virtual ~ConfigureSaveLocationCommand(void);
};

```
###### Logic\Command_Delete.cpp
``` cpp

#include "Command_Delete.h"

DeleteCommand::DeleteCommand(CommandTokens::SecondaryCommandType type2) : Command(CommandTokens::PrimaryCommandType::Delete) {
	_type2 = type2;
}

bool DeleteCommand::canUndo() {
	return true;
}

DeleteIndexCommand::DeleteIndexCommand(size_t index) : DeleteCommand(CommandTokens::SecondaryCommandType::Index) {
	_index = index;
	_entryIndex = std::numeric_limits<size_t>::infinity();
}

UIFeedback DeleteIndexCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	UIFeedback feedback;
	try {
		Task taskToDelete = runTimeStorage->find(_index);

		if (taskToDelete.isValid()) {
			_entryIndex = runTimeStorage->find(taskToDelete);
			assert(runTimeStorage->isValidIndex(_entryIndex));
			runTimeStorage->remove(_index);
			_taskDeleted = taskToDelete;
			char buffer[255];
			sprintf_s(buffer,MESSAGE_DELETE_INDEX_SUCCESS.c_str(),_index);
			std::string feedbackMessage(buffer);
			feedback = UIFeedback(runTimeStorage->refreshTasksToDisplay(),feedbackMessage);
			postExecutionAction(runTimeStorage);
		} 
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}
	return feedback;
}

UIFeedback DeleteIndexCommand::undo() {
	checkIsValidForUndo();
	_runTimeStorageExecuted -> insert(_taskDeleted, _entryIndex);
	_taskDeleted = Task();
	_entryIndex = std::numeric_limits<size_t>::infinity();
	postUndoAction();
	return UIFeedback(_runTimeStorageExecuted->refreshTasksToDisplay(), MESSAGE_DELETE_UNDO);
}

DeleteIndexCommand::~DeleteIndexCommand() {
}

DeleteBeforeCommand::DeleteBeforeCommand(ptime endDateTime) : DeleteCommand(CommandTokens::SecondaryCommandType::By) {
	assert(!endDateTime.is_special());
	_endDateTime = endDateTime;
}

UIFeedback DeleteBeforeCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	try {
		std::vector<Task> tasks = runTimeStorage ->getAllTasks();
		int numTask = tasks.size();
		for (int i = 0 ; i < numTask; ++i) {
			ptime time = tasks[i].getEndDateTime();
			if (!time.is_special()) {
				if (time < _endDateTime) {
					_tasksDeleted.push_back(tasks[i]);
					_indexTaskDeleted.push_back(i);
				}
			}
		}

		if (_tasksDeleted.empty()) {
			throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_DELETE_EMPTY);
		}

		numTask = _tasksDeleted.size();

		//backward delete so that index of tasks before it will not be affected.
		for (int i = numTask -1 ; i >= 0 ; --i) {
			runTimeStorage->removeEntry(_indexTaskDeleted[i]);
		}
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (COMMAND_EXECUTION_EXCEPTION e) {
		throw e;
	}

	postExecutionAction(runTimeStorage);
	std::string feedbackMessage;
	char buffer[255];
	sprintf_s(buffer,
		MESSAGE_DELETE_BEFORE_SUCCESS.c_str(),						
		boost::posix_time::to_simple_string(_endDateTime).c_str());
	feedbackMessage = std::string(buffer);
	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
}

UIFeedback DeleteBeforeCommand::undo(void) {
	checkIsValidForUndo();
	assert(!_tasksDeleted.empty());
	assert(_tasksDeleted.size() == _indexTaskDeleted.size());

	for (size_t i = 0 ; i < _tasksDeleted.size() ; ++i) {
		_runTimeStorageExecuted -> insert (_tasksDeleted[i], _indexTaskDeleted[i]);
	}

	_tasksDeleted.clear();
	_indexTaskDeleted.clear();
	postUndoAction();

	return UIFeedback(_runTimeStorageExecuted -> refreshTasksToDisplay(), MESSAGE_DELETE_UNDO);
}

DeleteBeforeCommand::~DeleteBeforeCommand(void) {
}

DeleteFromToCommand::DeleteFromToCommand(ptime startDateTime, ptime endDateTime) : DeleteCommand(CommandTokens::SecondaryCommandType::FromTo){
	assert(!(startDateTime.is_special() || endDateTime.is_special()));
	if (endDateTime < startDateTime) {
		throw COMMAND_CREATION_EXCEPTION (MESSAGE_END_LESS_THAN_START);
	}
	_startDateTime = startDateTime;
	_endDateTime = endDateTime;
}

UIFeedback DeleteFromToCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	try {
		std::vector<Task> tasks = runTimeStorage ->getAllTasks();
		int numTask = tasks.size();
		for (int i = 0 ; i < numTask; ++i) {
			ptime startDateTime = tasks[i].getStartDateTime();
			ptime endDateTime = tasks[i].getEndDateTime();
			if (!(startDateTime.is_special()||endDateTime.is_special())) {
				if (startDateTime > _startDateTime && endDateTime < _endDateTime) {
					_tasksDeleted.push_back(tasks[i]);
					_indexTaskDeleted.push_back(i);
				}
			}
		}

		if (_tasksDeleted.empty()) {
			throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_DELETE_EMPTY);
		}

		numTask = _tasksDeleted.size();

		//backward delete so that index of tasks before it will not be affected.
		for (int i = numTask -1 ; i >= 0 ; --i) {
			runTimeStorage->removeEntry(_indexTaskDeleted[i]);
		}
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (COMMAND_EXECUTION_EXCEPTION e) {
		throw e;
	}

	postExecutionAction(runTimeStorage);
	std::string feedbackMessage;
	char buffer[255];
	sprintf_s(buffer,
		MESSAGE_DELETE_FROMTO_SUCCESS.c_str(),
		boost::posix_time::to_simple_string(_startDateTime).c_str(),
		boost::posix_time::to_simple_string(_endDateTime).c_str());
	feedbackMessage = std::string(buffer);
	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
}

UIFeedback DeleteFromToCommand::undo(void) {
	checkIsValidForUndo();
	assert(!_tasksDeleted.empty());
	assert(_tasksDeleted.size() == _indexTaskDeleted.size());

	for (size_t i = 0 ; i < _tasksDeleted.size() ; ++i) {
		_runTimeStorageExecuted -> insert (_tasksDeleted[i], _indexTaskDeleted[i]);
	}

	_tasksDeleted.clear();
	_indexTaskDeleted.clear();
	postUndoAction();

	return UIFeedback(_runTimeStorageExecuted -> refreshTasksToDisplay(), MESSAGE_DELETE_UNDO);
}

DeleteFromToCommand::~DeleteFromToCommand(void) {
}

DeleteAllCommand::DeleteAllCommand(void) : DeleteCommand(CommandTokens::SecondaryCommandType::All){
}

UIFeedback DeleteAllCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	assert (_tasksDeleted.empty());
	UIFeedback feedback;
	try {
		_tasksDeleted = runTimeStorage->getAllTasks();
		runTimeStorage->removeAll();
		feedback = UIFeedback(runTimeStorage->refreshTasksToDisplay(), MESSAGE_DELETE_ALL_SUCCESS);
		postExecutionAction(runTimeStorage);
	} catch (EMPTY_STORAGE_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}

	return feedback;
}

UIFeedback DeleteAllCommand::undo() {
	checkIsValidForUndo();
	assert(!_tasksDeleted.empty());
	for (size_t i = 0 ; i < _tasksDeleted.size() ; ++i){
		_runTimeStorageExecuted -> add(_tasksDeleted[i]);
	}

	_tasksDeleted.clear();
	postUndoAction();
	return UIFeedback(_runTimeStorageExecuted->refreshTasksToDisplay(), MESSAGE_DELETE_UNDO);
}

DeleteAllCommand::~DeleteAllCommand() {
}

DeleteCompleteCommand::DeleteCompleteCommand (void) : DeleteCommand(CommandTokens::Completed){
}

UIFeedback DeleteCompleteCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	assert (_tasksDeleted.empty());
	UIFeedback feedback;
	try {
		std::vector<Task> tasks = runTimeStorage->getAllTasks();
		size_t numTask = tasks.size();
		for (size_t i = 0 ; i < numTask ; ++i) {
			if (tasks[i].isComplete()) {
				_tasksDeleted.push_back(tasks[i]);
				_indexTaskDeleted.push_back(i);
			}
		}

		if (_tasksDeleted.empty()) {
			throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_DELETE_EMPTY);
		}

		numTask = _tasksDeleted.size();

		//backward delete so that index of tasks before it will not be affected.
		for (int i = numTask -1 ; i >= 0 ; --i) {
			runTimeStorage->removeEntry(_indexTaskDeleted[i]);
		}		
	} catch (COMMAND_EXECUTION_EXCEPTION e) {
		throw e;
	}

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_DELETE_COMPLETE_SUCCESS.c_str());

	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), buffer);
}

UIFeedback DeleteCompleteCommand::undo(void) {
	checkIsValidForUndo();
	assert(!_tasksDeleted.empty());
	assert(_tasksDeleted.size() == _indexTaskDeleted.size());

	for (size_t i = 0 ; i < _tasksDeleted.size() ; ++i) {
		_runTimeStorageExecuted -> insert (_tasksDeleted[i], _indexTaskDeleted[i]);
	}

	_tasksDeleted.clear();
	_indexTaskDeleted.clear();
	postUndoAction();

	return UIFeedback(_runTimeStorageExecuted -> refreshTasksToDisplay(), MESSAGE_DELETE_UNDO);
}

DeleteCompleteCommand::~DeleteCompleteCommand(void) {
}
```
###### Logic\Command_Delete.h
``` h

#pragma once

#include "Command.h"

//Feedback message for different delete operation result
const std::string MESSAGE_DELETE_INDEX_SUCCESS = "Task at index %i have been deleted successfully.";
const std::string MESSAGE_DELETE_ALL_SUCCESS = "All tasks have been removed.";
const std::string MESSAGE_DELETE_BEFORE_SUCCESS = "All tasks end before %s have been removed.";
const std::string MESSAGE_DELETE_FROMTO_SUCCESS = "All tasks start after %s and end before %s have been removed.";
const std::string MESSAGE_DELETE_COMPLETE_SUCCESS = "All completed tasks have been removed.";
const std::string MESSAGE_DELETE_EMPTY = "No task suited the condition is found. No task is deleted.";

const std::string MESSAGE_DELETE_UNDO = "Previous delete operation is undoed.";

/**
 *	Virtual command sub class responsible for deleting task
 */
class DeleteCommand: public Command{
public:
	/**
	 *	Constructor
	 *	@param type2 Secondary command type to further specify delete command.
	 */
	DeleteCommand (CommandTokens::SecondaryCommandType type2);

	virtual UIFeedback Command::execute(RunTimeStorage*) = 0;
	virtual UIFeedback Command::undo() = 0;

	/**
	 *	Return true all the time.
	 */
	bool canUndo();
};

/**
 *	Delete command sub class responsible for deleting tasks based on index shown in display.
 */
class DeleteIndexCommand: public DeleteCommand{
private:
	/**
	 *	Index of the task to be deleted shown in display.
	 */
	size_t _index;

	/**
	 *	Task that has been deleted by the command.
	 *	Used for undo.
	 */
	Task _taskDeleted;

	/**
	 *	Original index of the task deleted in master vector.
	 *	Used for undo.
	 */
	size_t _entryIndex;
public:
	/**
	 *	Constructor
	 *	@param index Index of task to be deleted as shown in display.
	 */
	DeleteIndexCommand(size_t index);

	/**
	 *	Execution method of deleteIndexCommand.
	 *	Delete task based on its index shown in display.
	 */
	UIFeedback DeleteCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of deleteIndexCommand.
	 *	Recover the task deleted back to its original position.
	 */
	UIFeedback DeleteCommand::undo(void);

	/**
	 *	Destructor
	 */
	virtual ~DeleteIndexCommand();
#ifdef TESTMODE
	size_t getIndex() {
		return _index;
	}
#endif
};

/**
 *	Delete command sub class responsible for deleting all tasks that end before date time specified.
 */
class DeleteBeforeCommand: public DeleteCommand{
private:
	/**
	 *	All tasks that have been deleted during execution.
	 */
	std::vector<Task> _tasksDeleted;

	/**
	 *	Original indexs of all tasks deleted in master vector.
	 */
	std::vector<int> _indexTaskDeleted;
	
	/**
	 *	Reference date time for comparison during execution.
	 */
	ptime _endDateTime;
public:
	/**
	 *	Constructor
	 *	@param end Date time used as reference. All tasks that end before it will be deleted during execution.
	 */
	DeleteBeforeCommand(ptime end);

	/**
	 *	Execution method of DeleteEndBeforeCommand.
	 *	Delete all tasks that end before _endDateTime.
	 */
	UIFeedback DeleteCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of DeleteBeforeCommand.
	 *	Recover all tasks deleted back to its original index in master vector.
	 */
	UIFeedback DeleteCommand::undo(void);

	/**
	 *	Destructor
	 */
	virtual ~DeleteBeforeCommand(void);
#ifdef TESTMODE
	ptime getEndDateTime() {
		return _endDateTime;
	}
#endif
};

/**
 *	Delete command sub class responsible for deleting tasks from date time 1 to date time2.
 */
class DeleteFromToCommand: public DeleteCommand{
private:
	/**
	 *	All tasks that have been deleted during execution.
	 */
	std::vector<Task> _tasksDeleted;

	/**
	 *	Original indexs of all tasks deleted in master vector.
	 */
	std::vector<int> _indexTaskDeleted;

	/**
	 *	Reference date time for comparison during execution.
	 */
	ptime _startDateTime;

	/**
	 *	Reference date time for comparison during execution.
	 */
	ptime _endDateTime;
public:
	/**
	 *	Constructor
	 *	@param start Date time used as reference.
	 *	@param end Date time used as reference.
	 */
	DeleteFromToCommand(ptime start, ptime end);

	/**
	 *	Execution method of DeleteFromToCommand.
	 *	Delete all tasks that start after _startDateTime and end before _endDateTime.
	 */
	UIFeedback DeleteCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of DeleteFromToCommand.
	 *	Recover all tasks deleted back to its original index in master vector.
	 */
	UIFeedback DeleteCommand::undo(void);

	/**
	 *	Destructor
	 */
	virtual ~DeleteFromToCommand(void);
#ifdef TESTMODE
	ptime getEndDateTime() {
		return _endDateTime;
	}

	ptime getStartDateTime() {
		return _startDateTime;
	}
#endif
};

/**
 *	Delete command sub class responsible for deleting all tasks.
 */
class DeleteAllCommand : public DeleteCommand{
private:
	/**
	 *	All tasks that have been deleted during execution.
	 */
	std::vector<Task> _tasksDeleted;
public:
	/**
	 *	Constructor
	 */
	DeleteAllCommand(void);

	/**
	 *	Execution method of DeleteAllCommand.
	 *	Delete all tasks.
	 */
	UIFeedback DeleteCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of DeleteAllCommand.
	 *	Recover all tasks deleted back to its original index in master vector.
	 */
	UIFeedback DeleteCommand::undo(void);

	/**
	 *	Destructor
	 */
	virtual ~DeleteAllCommand(void);
};

/**
 *	Delete command sub class responsible for deleting all completed tasks.
 */
class DeleteCompleteCommand : public DeleteCommand {
private:
	/**
	 *	All tasks that have been deleted during execution.
	 */
	std::vector<Task> _tasksDeleted;

	/**
	 *	Original indexs of all tasks deleted in master vector.
	 */
	std::vector<int> _indexTaskDeleted;
public:
	/**
	 *	Constructor
	 */	
	DeleteCompleteCommand (void);

	/**
	 *	Execution method of DeleteCompleteCommand.
	 *	Delete all completed tasks.
	 */
	UIFeedback DeleteCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of DeleteCompleteCommand.
	 *	Recover all tasks deleted back to its original index in master vector.
	 */
	UIFeedback DeleteCommand::undo(void);

	/**
	 *	Destructor.
	 */
	virtual ~DeleteCompleteCommand(void);
};
```
###### Logic\Command_Display.cpp
``` cpp

#include "Command_Display.h"

DisplayCommand::DisplayCommand(Display_Type type) : Command (CommandTokens::PrimaryCommandType::Display){
	_newDisplayType = type;
}

UIFeedback DisplayCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	_oldDisplayType = runTimeStorage->getDisplayType();
	runTimeStorage->changeDisplayType(_newDisplayType);
	
	postExecutionAction(runTimeStorage);

	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), MESSAGE_DISPLAY_SUCCESS); 
}

UIFeedback DisplayCommand::undo() {
	checkIsValidForUndo();
	_runTimeStorageExecuted->changeDisplayType(_oldDisplayType);

	std::vector<Task> tasksToDisplay = _runTimeStorageExecuted->refreshTasksToDisplay();

	postUndoAction();

	return UIFeedback(tasksToDisplay, MESSAGE_DISPLAY_UNDO);
}

bool DisplayCommand::canUndo() {
	return true;
}

DisplayCommand::~DisplayCommand(void) {
}
```
###### Logic\Command_Display.h
``` h
#pragma once
#include "Command.h"

const std::string MESSAGE_DISPLAY_SUCCESS = "Display mode have been changed successfully.";
const std::string MESSAGE_DISPLAY_UNDO = "Display mode have been changed back successfully";

/**
 *	Command sub class responsible for changing display mode
 */
class DisplayCommand : public Command {
private:
	/**
	 *	Display_Type to change to
	 */
	Display_Type _newDisplayType;

	/**
	 *	Original Display_Type, used for undo
	 */
	Display_Type _oldDisplayType;
public:
	/**
	 *	Constructor
	 *	@param displayType Display_Type to change to
	 */
	DisplayCommand(Display_Type displayType);

	/**
	 *	Execution method of DisplayCommand.
	 *	Change display mode of the program.
	 */
	UIFeedback Command::execute(RunTimeStorage*);

	/**
	 *	Undo method of DisplayCommand.
	 *	Revert display mode back to the previous one.
	 */
	UIFeedback Command::undo();

	/**
	 *	Return true all the time.
	 */
	bool canUndo();

	/**
	 *	Destructor
	 */
	virtual ~DisplayCommand(void);
};
```
###### Logic\Command_Edit.cpp
``` cpp

#include "Command_Edit.h"

EditCommand::EditCommand(CommandTokens::SecondaryCommandType type2, size_t index) : Command(CommandTokens::PrimaryCommandType::Edit) {
	_type2 = type2;
	_index = index;
}

bool EditCommand::canUndo() {
	return true;
}

EditNameCommand::EditNameCommand(size_t index, std::string newTaskText):EditCommand(CommandTokens::SecondaryCommandType::Name, index) {
	_newTaskText = newTaskText;
}

UIFeedback EditNameCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);

	std::string feedbackMessage;

	assert (!_newTaskText.empty());

	try {
		Task& taskToEdit = runTimeStorage -> find(_index);
		_editIndex = runTimeStorage -> find(taskToEdit);
		_oldTaskText = taskToEdit.getTaskText();

		//Task object used to check for duplication after edit.
		Task testTask = taskToEdit;
		testTask.changeTaskText(_newTaskText);
		if (runTimeStorage->isDuplicate(testTask)) {
			throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_EDIT_DUPLICATE);
		}

		taskToEdit.changeTaskText(_newTaskText);

		char buffer[255];
		sprintf_s(buffer, MESSAGE_EDIT_NAME_SUCCESS.c_str(), _oldTaskText.c_str(), _newTaskText.c_str());
		feedbackMessage = std::string(buffer);

		postExecutionAction(runTimeStorage);
		return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
	} catch (INDEX_NOT_FOUND_EXCEPTION e){
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (COMMAND_EXECUTION_EXCEPTION e){
		throw e;
	}
}

UIFeedback EditNameCommand::undo() {
	checkIsValidForUndo();

	Task& taskToEdit = _runTimeStorageExecuted->getEntry(_editIndex);

	taskToEdit.changeTaskText(_oldTaskText);

	std::vector<Task> taskToDisplay = _runTimeStorageExecuted->refreshTasksToDisplay();
	postUndoAction();

	return UIFeedback(taskToDisplay, MESSAGE_EDIT_UNDO);
}

EditStartCommand::EditStartCommand(size_t index, ptime newStart) : EditCommand(CommandTokens::SecondaryCommandType::Start, index) {
	_newStart = newStart;
}

UIFeedback EditStartCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);

	std::string feedbackMessage;

	try {
		Task& taskToEdit = runTimeStorage -> find(_index);
		_editIndex = runTimeStorage -> find(taskToEdit);
		_oldStart = taskToEdit.getStartDateTime();

		//Task object used to check for duplication after edit.
		Task testTask = taskToEdit;
		testTask.changeStartDateTime(_newStart);
		if (runTimeStorage->isDuplicate(testTask)) {
			throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_EDIT_DUPLICATE);
		}

		taskToEdit.changeStartDateTime(_newStart);

		char buffer[255];
		std::string newStartString = boost::posix_time::to_simple_string(_newStart);
		sprintf_s(buffer, MESSAGE_EDIT_START_SUCCESS.c_str(), taskToEdit.getTaskText().c_str(), newStartString.c_str());
		feedbackMessage = std::string(buffer);

		postExecutionAction(runTimeStorage);
		return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (TASK_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (COMMAND_EXECUTION_EXCEPTION e){
		throw e;
	}
}

UIFeedback EditStartCommand::undo() {
	checkIsValidForUndo();

	Task& taskToEdit = _runTimeStorageExecuted->getEntry(_editIndex);

	taskToEdit.changeStartDateTime(_oldStart);

	std::vector<Task> taskToDisplay = _runTimeStorageExecuted->refreshTasksToDisplay();
	postUndoAction();

	return UIFeedback(taskToDisplay, MESSAGE_EDIT_UNDO);
}

EditEndCommand::EditEndCommand(size_t index, ptime newEnd) : EditCommand(CommandTokens::SecondaryCommandType::End, index) {
	_newEnd = newEnd;
}

UIFeedback EditEndCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	std::string feedbackMessage;
	try {
		Task& taskToEdit = runTimeStorage -> find(_index);
		_editIndex = runTimeStorage -> find(taskToEdit);
		_oldEnd = taskToEdit.getEndDateTime();

		//Task object used to check for duplication after edit.
		Task testTask = taskToEdit;
		testTask.changeEndDateTime(_newEnd);
		if (runTimeStorage->isDuplicate(testTask)) {
			throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_EDIT_DUPLICATE);
		}

		taskToEdit.changeEndDateTime(_newEnd);

		char buffer[255];
		std::string newEndString = boost::posix_time::to_simple_string(_newEnd);
		sprintf_s(buffer, MESSAGE_EDIT_END_SUCCESS.c_str(), taskToEdit.getTaskText().c_str(), newEndString.c_str());
		feedbackMessage = std::string(buffer);

		postExecutionAction(runTimeStorage);

		return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
	} catch(INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch(TASK_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (COMMAND_EXECUTION_EXCEPTION e){
		throw e;
	}
}

UIFeedback EditEndCommand::undo() {
	checkIsValidForUndo();

	Task& taskToEdit = _runTimeStorageExecuted->getEntry(_editIndex);

	taskToEdit.changeEndDateTime(_oldEnd);

	std::vector<Task> taskToDisplay = _runTimeStorageExecuted->refreshTasksToDisplay();
	postUndoAction();

	return UIFeedback(taskToDisplay, MESSAGE_EDIT_UNDO);
}
```
###### Logic\Command_Edit.h
``` h
#pragma once
#include "Command.h"

//Feedback message for different edit operation result
const std::string MESSAGE_EDIT_NAME_SUCCESS = "Task \"%s\" have been changed to \"%s\".";
const std::string MESSAGE_EDIT_NAME_EMPTY = "Task text cannot be empty. Task text is not changed.";
const std::string MESSAGE_EDIT_START_SUCCESS = "Task \"%s\" 's start date and time have been changed to \"%s\".";
const std::string MESSAGE_EDIT_END_SUCCESS = "Task \"%s\" 's end date and time have been changed to \"%s\".";
const std::string MESSAGE_EDIT_DUPLICATE = "Edit will cause task duplication, edit cannot be performed.";

const std::string MESSAGE_EDIT_UNDO = "Previous edit operation have been undoed successfully.";

/**
 *	Virtual Command sub class responsible for editing task attribute.
 */
class EditCommand: public Command {
protected:
	/**
	 *	Index of the task to be edited as shown in display(1-based)
	 */
	size_t _index;

	/**
	 *	Index of the task in master vector (0-based), used for undo
	 */
	size_t _editIndex;
public:
	/**
	 *	Constructor
	 *	@param type2 Secondary Command Type to further specify Edit Command
	 *	@param index Index of the task to be edited as shown in display (1-based)
	 */
	EditCommand(CommandTokens::SecondaryCommandType type2, size_t index);

	virtual UIFeedback Command::execute(RunTimeStorage*) = 0;
	virtual UIFeedback Command::undo(void) = 0;

	/**
	 *	Return true all the time
	 */
	bool canUndo(void);
};

/**
 *	EditCommand sub class responsible for editing task name
 */
class EditNameCommand: public EditCommand {
private:
	/**
	 *	New task name to change to
	 */
	std::string _newTaskText;

	/**
	 *	Original name of the edited task, used for undo
	 */
	std::string _oldTaskText;
public:
	/**
	 *	Constructor
	 *	@param index Index of the task to be edited as shown in display. (1-based)
	 *	@param newTaskText New task name to change to
	 */
	EditNameCommand(size_t index, std::string newTaskText);

	/**
	 *	Execution method of EditNameCommand.
	 *	Change name of the specified task based on index.
	 */
	UIFeedback EditCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of EditNameCommand.
	 *	Revert back name of edited task.
	 */
	UIFeedback EditCommand::undo();
};

/**
 *	EditCommand sub class responsible for editing start date time
 */
class EditStartCommand: public EditCommand {
private:
	/**
	 *	New start date time to change to
	 */
	ptime _newStart;

	/**
	 *	Original start date time of the edited task, used for undo
	 */
	ptime _oldStart;
public:
	/**
	 *	Constructor
	 *	@param index Index of the task to be edited as shown in display. (1-based)
	 *	@param newStart New start date time to change to
	 */
	EditStartCommand(size_t index, ptime newStart);

	/**
	 *	Execution method of EditStartCommand.
	 *	Change start date time of the specified task based on index.
	 */
	UIFeedback EditCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of EditStartCommand.
	 *	Revert back start date time of edited task.
	 */
	UIFeedback EditCommand::undo();
};

/**
 *	EditCommand sub class responsible for editing end date time
 */
class EditEndCommand: public EditCommand {
private:
	/**
	 *	New end date time to change to
	 */
	ptime _newEnd;

	/**
	 *	Original end date time of the edited task, used for undo
	 */
	ptime _oldEnd; 
public:
	/**
	 *	Constructor
	 *	@param index Index of the task to be edited as shown in display. (1-based)
	 *	@param newEnd New end date time to change to
	 */
	EditEndCommand(size_t index, ptime newEnd);

	/**
	 *	Execution method of EditEndCommand.
	 *	Change end date time of the specified task based on index.
	 */
	UIFeedback EditCommand::execute(RunTimeStorage*);

	/**
	 *	Undo method of EditEndCommand.
	 *	Revert back end date time of edited task.
	 */
	UIFeedback EditCommand::undo();
};
```
###### Logic\Command_Export.cpp
``` cpp

#include "Command_Export.h"

ExportCommand::ExportCommand(std::string filePath) : Command(CommandTokens::PrimaryCommandType::Export) {
	if (filePath.empty()) {
		throw COMMAND_CREATION_EXCEPTION(MESSAGE_EXPORT_INVALID_FILEPATH);
	}
	_filePath = filePath;
}

UIFeedback ExportCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	try {
		runTimeStorage -> saveToFile(_filePath);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (INVALID_PATH_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}
	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_EXPORT_SUCCESS.c_str(), _filePath.c_str());
	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), std::string(buffer));
}

UIFeedback ExportCommand::undo() {
	assert(false);
	return UIFeedback();
}

bool ExportCommand::canUndo() {
	return false;
}

ExportCommand::~ExportCommand(void){
}
```
###### Logic\Command_Export.h
``` h
#pragma once
#include "Command.h"

const std::string MESSAGE_EXPORT_INVALID_FILEPATH = "Invalid file path. Export cannot be done.";
const std::string MESSAGE_EXPORT_SUCCESS = "Data have been exported to %s.";

/**
 *	Command sub class responsible for exporting save file
 */
class ExportCommand : public Command {
private:
	/**
	 *	File path for export location
	 */
	std::string _filePath;
public:
	/**
	 *	Constructor
	 *	@param filePath File path for export location.
	 */
	ExportCommand(std::string filePath);

	/**
	 *	Execution method of ExportCommand.
	 *	Export save file to target location.
	 */
	UIFeedback Command::execute(RunTimeStorage*);

	UIFeedback Command::undo();
	/**
	 *	Return false all the time.
	 */
	bool Command::canUndo();

	/**
	 *	Destructor
	 */
	~ExportCommand(void);
};

```
###### Logic\Command_Import.cpp
``` cpp

#include "Command_Import.h"

ImportCommand::ImportCommand(std::string filePath) : Command(CommandTokens::PrimaryCommandType::Import) {
	if (filePath.empty()) {
		throw COMMAND_CREATION_EXCEPTION(MESSAGE_IMPORT_INVALID_FILEPATH);
	}
	_filePath = filePath;
}

UIFeedback ImportCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	try {
		runTimeStorage -> loadFromFile(_filePath);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (INVALID_PATH_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_IMPORT_SUCCESS.c_str(), _filePath.c_str());
	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), std::string(buffer));
}

UIFeedback ImportCommand::undo() {
	assert(false);
	return UIFeedback();
}

bool ImportCommand::canUndo() {
	return false;
}

ImportCommand::~ImportCommand(void){
}
```
###### Logic\Command_Import.h
``` h
#pragma once
#include "Command.h"

const std::string MESSAGE_IMPORT_INVALID_FILEPATH = "Invalid file path. Import cannot be done.";
const std::string MESSAGE_IMPORT_SUCCESS = "Data have been imported from %s.";

/**
 *	Command sub class responsible for importing save file
 */
class ImportCommand : public Command {
private:
	/**
	 *	File path of save file to be loaded
	 */
	std::string _filePath;
public:
	/**
	 *	Constructor
	 *	@param filePath File path of save file to be loaded
	 */
	ImportCommand(std::string filePath);

	/**
	 *	Execution method of ImportCommand.
	 *	Import data from save file at target location.
	 */
	UIFeedback Command::execute(RunTimeStorage*);

	UIFeedback Command::undo();

	/**
	 *	Return true all the time.
	 */
	bool Command::canUndo();

	/**
	 *	Destructor
	 */
	~ImportCommand(void);
};
```
###### Logic\Command_Refresh.cpp
``` cpp

#include "Command_Refresh.h"

RefreshCommand::RefreshCommand(void) : Command(CommandTokens::PrimaryCommandType::Refresh)
{
}

UIFeedback RefreshCommand::execute(RunTimeStorage* runTimeStorage) {
	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), "");
}

UIFeedback RefreshCommand::undo() {
	assert(false);
	return UIFeedback();
}


RefreshCommand::~RefreshCommand(void){
}
```
###### Logic\Command_Refresh.h
``` h
#pragma once

#include "Command.h"

/**
 *	Command sub class responsible to refresh display on UI
 */
class RefreshCommand : public Command {
public:
	/**
	 *	Constructor
	 */
	RefreshCommand(void);

	/**
	 *	Return false all the time
	 */
	bool Command::canUndo() {
		return false;
	}

	/**
	 *	Execution method of RefreshCommand.
	 *	Refresh display on UI.
	 */
	UIFeedback execute(RunTimeStorage*);
	UIFeedback undo();

	/**
	 *	Destructor.
	 */
	~RefreshCommand(void);
};

```
###### Logic\Command_Search.cpp
``` cpp

#include "Command_Search.h"

bool compareCount(const std::pair<int, Task>&i, const std::pair<int, Task>&j) {
	return i.first > j.first;
}

SearchCommand::SearchCommand(void) : Command(CommandTokens::Search) {
}

UIFeedback SearchCommand::undo() {
	assert(false);
	return UIFeedback();
}

bool SearchCommand::canUndo() {
	return false;
}

SearchCommand::~SearchCommand(void) {
}

SearchStartCommand::SearchStartCommand(ptime start) : SearchCommand() {
	assert(!start.is_special());
	_start = start;
}

SearchStartCommand::~SearchStartCommand(void) {
}

SearchStartBeforeCommand::SearchStartBeforeCommand(ptime start) : SearchStartCommand(start) {
	_type2 = CommandTokens::SecondaryCommandType::StartBefore;
}

UIFeedback SearchStartBeforeCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	_searchResult.clear();
	std::vector<Task>& tasks = runTimeStorage -> getAllTasks();

	for (size_t i = 0 ; i < tasks.size() ; ++i) {
		ptime start = tasks[i].getStartDateTime();
		if (!start.is_special()) {
			if (start < _start) {
				_searchResult.push_back(tasks[i]);
			}
		}
	}

	if (_searchResult.empty()) {
		throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_NO_TASK_FOUND);
	}

	std::stable_sort(_searchResult.begin(), _searchResult.end(), Task::sortByStartDateTimeAscending);
	runTimeStorage -> setTasksToDisplay(_searchResult);

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());

	return UIFeedback(runTimeStorage->getTasksToDisplay(), std::string(buffer));
}

SearchStartBeforeCommand::~SearchStartBeforeCommand(void) {
}

SearchStartAfterCommand::SearchStartAfterCommand(ptime start) : SearchStartCommand(start) {
	_type2 = CommandTokens::SecondaryCommandType::StartAfter;
}

UIFeedback SearchStartAfterCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	_searchResult.clear();
	std::vector<Task>& tasks = runTimeStorage -> getAllTasks();

	for (size_t i = 0 ; i < tasks.size() ; ++i) {
		ptime start = tasks[i].getStartDateTime();
		if (!start.is_special()) {
			if (start > _start) {
				_searchResult.push_back(tasks[i]);
			}
		}
	}

	if (_searchResult.empty()) {
		throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_NO_TASK_FOUND);
	}

	std::stable_sort(_searchResult.begin(), _searchResult.end(), Task::sortByStartDateTimeAscending);
	runTimeStorage -> setTasksToDisplay(_searchResult);

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());

	return UIFeedback(runTimeStorage->getTasksToDisplay(), std::string(buffer));
}

SearchStartAfterCommand::~SearchStartAfterCommand(void) {
}

SearchEndCommand::SearchEndCommand(ptime end) : SearchCommand() {
	assert(!end.is_special());
	_end = end;
}

SearchEndCommand::~SearchEndCommand(void) {
}

SearchEndBeforeCommand::SearchEndBeforeCommand(ptime end) : SearchEndCommand(end) {
	_type2 = CommandTokens::SecondaryCommandType::EndBefore;
}

UIFeedback SearchEndBeforeCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	_searchResult.clear();
	std::vector<Task>& tasks = runTimeStorage -> getAllTasks();

	for (size_t i = 0 ; i < tasks.size() ; ++i) {
		ptime end = tasks[i].getEndDateTime();
		if (!end.is_special()) {
			if (end < _end) {
				_searchResult.push_back(tasks[i]);
			}
		}
	}

	if (_searchResult.empty()) {
		throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_NO_TASK_FOUND);
	}

	std::stable_sort(_searchResult.begin(), _searchResult.end(), Task::sortByEndDateTimeAscending);
	runTimeStorage -> setTasksToDisplay(_searchResult);

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());

	return UIFeedback(runTimeStorage->getTasksToDisplay(), std::string(buffer));
}

SearchEndBeforeCommand::~SearchEndBeforeCommand(void) {
}

SearchEndAfterCommand::SearchEndAfterCommand(ptime end) : SearchEndCommand(end) {
	_type2 = CommandTokens::SecondaryCommandType::EndAfter;
}

UIFeedback SearchEndAfterCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	_searchResult.clear();
	std::vector<Task>& tasks = runTimeStorage -> getAllTasks();

	for (size_t i = 0 ; i < tasks.size() ; ++i) {
		ptime end = tasks[i].getEndDateTime();
		if (!end.is_special()) {
			if (end > _end) {
				_searchResult.push_back(tasks[i]);
			}
		}
	}

	if (_searchResult.empty()) {
		throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_NO_TASK_FOUND);
	}

	std::stable_sort(_searchResult.begin(), _searchResult.end(), Task::sortByEndDateTimeAscending);
	runTimeStorage -> setTasksToDisplay(_searchResult);

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());

	return UIFeedback(runTimeStorage->getTasksToDisplay(), std::string(buffer));
}

SearchEndAfterCommand::~SearchEndAfterCommand(void) {
}

SearchTagsCommand::SearchTagsCommand(std::vector<std::string> tags) : SearchCommand() {
	for (size_t i = 0 ; i < tags.size() ; ++i) {
		_tags.insert(tags[i]);
	}
	_type2 = CommandTokens::SecondaryCommandType::Tags;
}

UIFeedback SearchTagsCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	std::set<std::string>::iterator iter;
	std::vector<Task>& tasks = runTimeStorage->getAllTasks();
	size_t numTask = tasks.size();
	std::pair<int,Task>* taskCounter = new std::pair<int,Task> [numTask];

	for (size_t i = 0 ; i < numTask ; ++i) {
		taskCounter[i] = std::make_pair(0, tasks[i]);
	}

	for (iter = _tags.begin() ; iter != _tags.end() ; ++iter) {
		for (size_t i = 0 ; i < numTask ; ++i) {
			if (tasks[i].getTags().find(*iter) != tasks[i].getTags().end()) {
				taskCounter[i].first++;
			}
		}
	}

	std::stable_sort(taskCounter, taskCounter + numTask, compareCount);

	for (size_t i = 0 ; i < numTask ; ++i) {
		if (taskCounter[i].first == 0) {
			break;
		} else {
			_searchResult.push_back(taskCounter[i].second);
		}
	}

	runTimeStorage->setTasksToDisplay(_searchResult);
	delete[] taskCounter;

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());

	return UIFeedback(runTimeStorage->getTasksToDisplay(), buffer);
}

SearchTagsCommand::~SearchTagsCommand(void) {
}

SearchNameCommand::SearchNameCommand(std::string searchString) {
	_searchString = searchString;
}

UIFeedback SearchNameCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	std::vector<Task>& tasks = runTimeStorage->getAllTasks();
	size_t numTask = tasks.size();

	std::smatch m;

	char buffer[255];
	sprintf_s(buffer,SEARCH_FORMAT_STRING.c_str(),_searchString.c_str());
	std::regex e(buffer, std::regex_constants::ECMAScript | std::regex_constants::icase);

	for (size_t i = 0 ; i < numTask ; ++i) {
		if (std::regex_search(tasks[i].getTaskText(),m,e)) {
			_searchResult.push_back(tasks[i]);
		}
	}

	if (_searchResult.empty()) {
		throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_NO_TASK_FOUND);
	}

	runTimeStorage -> setTasksToDisplay(_searchResult);

	postExecutionAction(runTimeStorage);

	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());

	return UIFeedback(runTimeStorage->getTasksToDisplay(), std::string(buffer));
}

SearchNameCommand::~SearchNameCommand() {
}

SearchFromToCommand::SearchFromToCommand(ptime start, ptime end) {
	_startDateTime = start;
	_endDateTime = end;
}

UIFeedback SearchFromToCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);

	std::vector<Task>& tasks = runTimeStorage->getAllTasks();

	size_t numTask = tasks.size();

	for (size_t i = 0 ; i < numTask ; ++i) {
		ptime start = tasks[i].getStartDateTime();
		ptime end = tasks[i].getEndDateTime();
		if (!start.is_special() && !end.is_special()) {
			if (start >= _startDateTime && end <= _endDateTime) {
				_searchResult.push_back(tasks[i]);
			}
		}
	}

	if (_searchResult.empty()) {
		throw COMMAND_EXECUTION_EXCEPTION(MESSAGE_NO_TASK_FOUND);
	}

	runTimeStorage->setTasksToDisplay(_searchResult);

	postExecutionAction(runTimeStorage);

	char buffer[255];
	sprintf_s(buffer, MESSAGE_SEARCH_SUCCESS.c_str(), _searchResult.size());
	return UIFeedback(runTimeStorage->getTasksToDisplay(), buffer);
}

SearchFromToCommand::~SearchFromToCommand(void) {
}
```
###### Logic\Command_Search.h
``` h
#pragma once

#include "Command.h"

const std::string MESSAGE_SEARCH_SUCCESS = "%i task(s) have been found.";
const std::string MESSAGE_NO_TASK_FOUND = "There is no task fulfilling the search criteria.";
const std::string SEARCH_FORMAT_STRING = "(%s)([^ ]*)";

/**
 *	Virtual Command sub class responsible for searching tasks
 */
class SearchCommand : public Command {
protected:
	/**
	 *	Vector responsible to store searchResult
	 */
	std::vector<Task> _searchResult;
public:
	/**
	 *	Constructor
	 */
	SearchCommand(void);
	virtual UIFeedback Command::execute(RunTimeStorage*) = 0;
	UIFeedback Command::undo();

	/**
	 *	Return false all the time.
	 */
	bool canUndo();

	/**
	 *	Destructor.
	 */
	virtual ~SearchCommand(void);
};

/**
 *	Virtual SearchCommand sub class responsible for searching tasks based on start date time.
 */
class SearchStartCommand : public SearchCommand {
protected:
	/**
	 *	Start date time to be used for comparison
	 */
	ptime _start;
public:
	/**
	 *	Constructor.
	 *	@param start Start date time to be used for comparison.
	 */
	SearchStartCommand(ptime start);

	virtual UIFeedback SearchCommand::execute(RunTimeStorage*) = 0;
	
	/**
	 *	Destructor
	 */
	virtual ~SearchStartCommand(void);
};

/**
 *	SearchStartCommand sub class responsible for searching tasks before start date time specified.
 */
class SearchStartBeforeCommand : public SearchStartCommand {
public:
	/**
	 *	Constructor.
	 *	@param start Start date time to be used for comparison.
	 */
	SearchStartBeforeCommand(ptime start);

	/**
	 *	Execution method of SearchStartBeforeCommand
	 *	Search for all tasks before _start
	 */
	UIFeedback SearchStartCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchStartBeforeCommand(void);
};

/**
 *	SearchStartCommand sub class responsible for searching tasks after start date time specified.
 */
class SearchStartAfterCommand : public SearchStartCommand {
public:
	/**
	 *	Constructor.
	 *	@param start Start date time to be used for comparison.
	 */
	SearchStartAfterCommand(ptime start);

	/**
	 *	Execution method of SearchStartAfterCommand
	 *	Search for all tasks after _start
	 */
	UIFeedback SearchStartCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchStartAfterCommand(void);
};

/**
 *	Virtual SearchCommand sub class responsible for searching tasks based on end date time.
 */
class SearchEndCommand : public SearchCommand {
protected:
	/**
	 *	End date time to be used for comparison
	 */
	ptime _end;
public:
	/**
	 *	Constructor.
	 *	@param end End date time to be used for comparison.
	 */
	SearchEndCommand(ptime end);
	
	virtual UIFeedback SearchCommand::execute(RunTimeStorage*) = 0;

	/**
	 *	Destructor
	 */
	virtual ~SearchEndCommand(void);
};

/**
 *	SearchEndCommand sub class responsible for searching tasks before date time specified.
 */
class SearchEndBeforeCommand : public SearchEndCommand {
public:
	/**
	 *	Constructor.
	 *	@param end End date time to be used for comparison.
	 */
	SearchEndBeforeCommand(ptime);

	/**
	 *	Execution method of SearchEndBeforeCommand
	 *	Search for all tasks before _end
	 */
	UIFeedback SearchEndCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchEndBeforeCommand(void);
};

/**
 *	SearchEndCommand sub class responsible for searching tasks after date time specified.
 */
class SearchEndAfterCommand : public SearchEndCommand {
public:
	/**
	 *	Constructor.
	 *	@param end End date time to be used for comparison.
	 */
	SearchEndAfterCommand(ptime);

	/**
	 *	Execution method of SearchEndBeforeCommand
	 *	Search for all tasks after _end
	 */
	UIFeedback SearchEndCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchEndAfterCommand(void);
};

/**
 *	SearchCommand sub class responsible for searching tasks based on tags
 */
class SearchTagsCommand : public SearchCommand {
private:
	/**
	 *	Tags to be used for searching tasks.
	 */
	std::set<std::string> _tags;
public:
	/**
	 *	Constructor
	 *	@param tags Tags to be used for searching tasks.
	 */
	SearchTagsCommand(std::vector<std::string> tags);

	/**
	 *	Execution method of SearchTagsCommand
	 *	Search for all tasks with at least 1 matching tag.
	 */
	UIFeedback SearchCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchTagsCommand(void);
};

/**
 *	SearchCommand sub class responsible for searching tasks based on name
 */
class SearchNameCommand : public SearchCommand {
private:
	/**
	 *	Name to be used for searching tasks.
	 */
	std::string _searchString;
public:
	/**
	 *	Constructor
	 *	@param searchString Name to be used for searching tasks.
	 */
	SearchNameCommand(std::string searchString);

	/**
	 *	Execution method of SearchNameCommand
	 *	Search for all tasks with _searchString as substring (Case insensitive).
	 */
	UIFeedback SearchCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchNameCommand(void);
};

/**
 *	SearchCommand sub class responsible for searching all tasks between start and end date time specified.
 */
class SearchFromToCommand : public SearchCommand {
private:
	/**
	 *	Start date time to be used for comparison.
	 */
	ptime _startDateTime;

	/**
	 *	End date time to be used for comparison.
	 */
	ptime _endDateTime;
public:
	/**
	 *	Constructor.
	 *	@param start Start date time to be used for comparison.
	 *	@param end End date time to be used for comparison.
	 */
	SearchFromToCommand(ptime start, ptime end);

	/**
	 *	Execution method of SearchFromToCommand.
	 *	Search for all tasks that start after _startDateTime and end before _endDateTime
	 */
	UIFeedback SearchCommand::execute(RunTimeStorage*);

	/**
	 *	Destructor.
	 */
	virtual ~SearchFromToCommand(void);
};
```
###### Logic\Command_Set.cpp
``` cpp

#include "Command_Set.h"

ALREADY_COMPLETE_EXCEPTION::ALREADY_COMPLETE_EXCEPTION(int index) : std::exception() {
	sprintf_s(_message, MESSAGE_SET_COMPLETE_NO_CHANGE.c_str(), index);
}

const char* ALREADY_COMPLETE_EXCEPTION::what(void) const throw() {
	return _message;
}


SetCompleteCommand::SetCompleteCommand(size_t index) : Command(CommandTokens::PrimaryCommandType::MarkAsComplete) {
	_type2 = CommandTokens::SecondaryCommandType::Index;
	_index = index;
}

UIFeedback SetCompleteCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);

	UIFeedback feedback;

	try {
		Task& taskToSet = runTimeStorage->find(_index);
		_setIndex = runTimeStorage->find(taskToSet);
		std::string feedbackMessage;
		char buffer[255];
		if (taskToSet.isComplete()) {
			throw ALREADY_COMPLETE_EXCEPTION(_index);
		}
		taskToSet.toggleComplete();
		
		postExecutionAction(runTimeStorage);

		sprintf_s(buffer, MESSAGE_SET_COMPLETE_SUCCESS.c_str(), _index);

		feedbackMessage = std::string(buffer);
		feedback = UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (ALREADY_COMPLETE_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}
	return feedback;
}

UIFeedback SetCompleteCommand::undo() {
	checkIsValidForUndo();

	Task& taskToSet = _runTimeStorageExecuted->getEntry(_setIndex);

	assert(taskToSet.isComplete());
	taskToSet.toggleComplete();

	postUndoAction();

	return UIFeedback(_runTimeStorageExecuted->refreshTasksToDisplay(), MESSAGE_SET_UNDO);
}

bool SetCompleteCommand::canUndo() {
	return true;
}
```
###### Logic\Command_Set.h
``` h
#pragma once

#include "Command.h"

//Feedback message for set complete operation
const std::string MESSAGE_SET_COMPLETE_SUCCESS = "Task at index %i have been set to complete.";
const std::string MESSAGE_SET_COMPLETE_NO_CHANGE = "Task at index %i is already complete, no change is made.";
const std::string MESSAGE_SET_COMPLETE_FAIL = "No task is found at index %i.";

const std::string MESSAGE_SET_UNDO = "Task's complete status have been reverted.";

class ALREADY_COMPLETE_EXCEPTION : public std::exception {
private:
	char _message[255];
public:
	explicit ALREADY_COMPLETE_EXCEPTION(int index);

	const char* what(void) const throw();
};

class SetCompleteCommand: public Command {
private:
	size_t _index;
	size_t _setIndex;
public:
	SetCompleteCommand(size_t index);
	UIFeedback Command::execute(RunTimeStorage*);
	UIFeedback Command::undo();
	bool canUndo();
};
```
###### Logic\Command_Sort.cpp
``` cpp

#include "Command_Sort.h"

SortCommand::SortCommand(Sort_Type type) : Command (CommandTokens::PrimaryCommandType::Sort){
	_newSortType = type;
}

UIFeedback SortCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	_oldSortType = runTimeStorage->getSortType();
	runTimeStorage->changeSortType(_newSortType);
	postExecutionAction(runTimeStorage);

	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), MESSAGE_SORT_SUCCESS); 
}

UIFeedback SortCommand::undo() {
	checkIsValidForUndo();
	_runTimeStorageExecuted->changeSortType(_oldSortType);

	std::vector<Task> tasksToDisplay = _runTimeStorageExecuted->refreshTasksToDisplay();

	postUndoAction();

	return UIFeedback(tasksToDisplay, MESSAGE_SORT_UNDO);
}

bool SortCommand::canUndo() {
	return true;
}

SortCommand::~SortCommand(void) {
}
```
###### Logic\Command_Sort.h
``` h
#pragma once

#include "Command.h"

const std::string MESSAGE_SORT_SUCCESS = "Sort mode have been changed successfully.";
const std::string MESSAGE_SORT_UNDO = "Sort mode have been changed back successfully";

class SortCommand : public Command {
private:
	Sort_Type _newSortType;
	Sort_Type _oldSortType;
public:
	SortCommand(Sort_Type);
	UIFeedback Command::execute(RunTimeStorage*);
	UIFeedback Command::undo();
	bool canUndo();
	virtual ~SortCommand(void);
};
```
###### Logic\Command_Tag.cpp
``` cpp

#include "Command_Tag.h"

TagCommand::TagCommand(size_t index, std::vector<std::string> tags) : Command(CommandTokens::PrimaryCommandType::Tag) {
	_index = index;
	_tags = tags;
	_type2 = CommandTokens::Index;
}

UIFeedback TagCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	std::string feedbackMessage;
	try {
		Task& taskToTag = runTimeStorage->find(_index);
		_tagIndex = runTimeStorage->find(taskToTag);
		for (size_t i = 0 ; i < _tags.size() ; ++i) {
			try {
				taskToTag.addTag(_tags[i]);
				_successTags.push_back(_tags[i]);
			} catch (TAG_LIMIT_EXCEPTION e) {
				throw e;
			} catch (TASK_EXCEPTION e){
				feedbackMessage += "\n";
				feedbackMessage += std::string(e.what());
			}
		}
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (TASK_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}

	if (_successTags.size() > 0) {
		postExecutionAction(runTimeStorage);
		char buffer[255];
		sprintf_s(buffer, MESSAGE_TAG_SUCCESS.c_str(), _index, _successTags.size());
		feedbackMessage += std::string(buffer);
	}

	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);
}

UIFeedback TagCommand::undo() {
	checkIsValidForUndo();
	Task& taskToUntag = _runTimeStorageExecuted->getEntry(_tagIndex);
	for (size_t i = 0 ; i < _successTags.size() ; ++i) {
		taskToUntag.removeTag(_successTags[i]);
	}
	postUndoAction();

	return UIFeedback(_runTimeStorageExecuted->refreshTasksToDisplay(), MESSAGE_TAG_UNDO);
}

bool TagCommand::canUndo() {
	return true;
}

TagCommand::~TagCommand(void) {
}
```
###### Logic\Command_Tag.h
``` h
#pragma once

#include "Command.h"

const std::string MESSAGE_TAG_SUCCESS = "Task at index %i have %i new tag(s) added.";
const std::string MESSAGE_TAG_UNDO = "Previous tag operation have been undoed.";

class TagCommand : public Command {
private:
	size_t _index;
	std::vector<std::string> _tags;
	std::vector<std::string> _successTags;
	int _tagIndex;
public:
	TagCommand(size_t, std::vector<std::string>);
	UIFeedback Command::execute(RunTimeStorage*);
	UIFeedback Command::undo();
	bool canUndo();
	~TagCommand(void);
};
```
###### Logic\Command_Untag.cpp
``` cpp

#include "Command_Untag.h"

UntagCommand::UntagCommand(size_t index, std::vector<std::string> untags) : Command(CommandTokens::Untag) {
	_index = index;
	_untags = untags;
	_type2 = CommandTokens::Index;
}

UIFeedback UntagCommand::execute(RunTimeStorage* runTimeStorage) {
	checkIsValidForExecute(runTimeStorage);
	std::string feedbackMessage;
	try {
		Task& taskToUntag = runTimeStorage->find(_index);
		_untagIndex = runTimeStorage->find(taskToUntag);
		for (size_t i = 0 ; i < _untags.size() ; ++i) {
			try {
				taskToUntag.removeTag(_untags[i]);
				_successUntags.push_back(_untags[i]);
			} catch (TASK_EXCEPTION e){
				feedbackMessage += std::string(e.what());
				feedbackMessage += "\n";
			}
		}
	} catch (INDEX_NOT_FOUND_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	} catch (TASK_EXCEPTION e) {
		throw COMMAND_EXECUTION_EXCEPTION(e.what());
	}

	if (_successUntags.size() > 0) {
		postExecutionAction(runTimeStorage);
		char buffer[255];
		sprintf_s(buffer, MESSAGE_UNTAG_SUCCESS.c_str(), _index, _successUntags.size());
		feedbackMessage += std::string(buffer);
	}

	return UIFeedback(runTimeStorage->refreshTasksToDisplay(), feedbackMessage);	
}
UIFeedback UntagCommand::undo() {
	checkIsValidForUndo();
	Task& taskToUntag = _runTimeStorageExecuted->getEntry(_untagIndex);
	for (size_t i = 0 ; i < _successUntags.size() ; ++i) {
		taskToUntag.addTag(_successUntags[i]);
	}
	postUndoAction();

	return UIFeedback(_runTimeStorageExecuted->refreshTasksToDisplay(), MESSAGE_UNTAG_UNDO);	
}

bool UntagCommand::canUndo() {
	return true;
}

UntagCommand::~UntagCommand(void)
{
}
```
###### Logic\Command_Untag.h
``` h
#pragma once

#include "Command.h"

const std::string MESSAGE_UNTAG_SUCCESS = "Task at index %i have %i tag(s) removed.";
const std::string MESSAGE_UNTAG_UNDO = "Previous untag operation have been undoed.";

class UntagCommand : public Command {
private:
	std::vector<std::string> _untags;
	std::vector<std::string> _successUntags;
	size_t _index;
	size_t _untagIndex;

public:
	UntagCommand(size_t, std::vector<std::string>);
	UIFeedback Command::execute(RunTimeStorage*);
	UIFeedback Command::undo();
	bool Command::canUndo();
	~UntagCommand(void);
};
```
###### Logic\Logic.cpp
``` cpp

#include "Logic.h"

Logic::Logic()  {
	_commandExecutor = new CommandExecutor();
	logger = Logger::getInstance();
	logger->logINFO("Logic is initialized.");
}

UIFeedback Logic::executeCommand(std::string userString) {
	UIFeedback feedback;

	logger->logINFO("\"" + userString + "\" is sent to parser for parsing.");

	CommandTokens commandTokens = _parser.parse(userString);
	try {
		if (commandTokens.getPrimaryCommand() == CommandTokens::PrimaryCommandType::Undo) {
			return _commandExecutor->undo();
		}
		Command* command = _commandCreator.process(commandTokens);
		feedback = _commandExecutor->execute(command);
	} catch (INVALID_COMMAND_EXCEPTION e) {
		throw std::string(e.what());
	} catch (COMMAND_CREATION_EXCEPTION e) {
		throw std::string(e.what());
	} catch (COMMAND_EXECUTION_EXCEPTION e) {
		throw std::string(e.what());
	} catch (UNDO_EXCEPTION e) {
		throw std::string(e.what());
	} catch (std::exception e) {
		throw std::string(e.what());
	}
	return feedback;
}

Logic::~Logic() {
	delete _commandExecutor;
}
```
###### Logic\Logic.h
``` h

#pragma once

#include "Task.h"
#include "UIFeedback.h"
#include "CommandExecutor.h"
#include "CommandCreator.h"
#include "..\Parser\Parser.h"
#include "..\Logger\Logger.h"

using namespace API;

class Logic {
private:
	CommandExecutor* _commandExecutor;
	CommandCreator _commandCreator;
	Parser _parser;
	Logger* logger;

public:
	Logic();

	UIFeedback executeCommand(std::string userString);

	virtual ~Logic();
};
```
###### Logic\RunTimeStorage.cpp
``` cpp

#include "RunTimeStorage.h"

//Constructor
RunTimeStorage::RunTimeStorage(){
	//Default display and sort mode for initialization
	_displayMode = Display_Type::displayAll;
	_sortMode = Sort_Type::sortByEntryOrder;

	_physicalStorageHandler = new PhysicalStorageHandler();
	try {
		_physicalStorageHandler->loadFromFile(_tasks);
	} catch (INVALID_FILE_EXCEPTION e) {
	}
}

//Getter
std::vector<Task>& RunTimeStorage::getAllTasks() {
	return _tasks;
}

std::vector<Task>& RunTimeStorage::getTasksToDisplay() {
	return _tasksToDisplay;
}

std::vector<Task>& RunTimeStorage::refreshTasksToDisplay() {
	updateDisplay();
	return _tasksToDisplay;
}

void RunTimeStorage::setTasksToDisplay(std::vector<Task> tasks) {
	for (size_t i = 0 ; i < tasks.size() ; ++i) {
		assert(std::find(_tasks.begin(), _tasks.end(), tasks[i]) != _tasks.end());
	}

	_tasksToDisplay = tasks;
}

//return the task reference object in _tasks based on index of _tasksToDisplay
//index is provided by user, thus it is in base-1 (start from 1 instead of 0)
Task& RunTimeStorage::find(size_t index) {
	if (index > _tasksToDisplay.size()) {
		throw INDEX_NOT_FOUND_EXCEPTION(index);
	}

	Task taskToReturn = _tasksToDisplay[index-1];
	std::vector<Task>::iterator iter = std::find(_tasks.begin(), _tasks.end(), taskToReturn);

	return *iter;
}

//find index of task in _tasks
//used for undo purpose whereby editing task on exact index is needed
//return index is in base-0
size_t RunTimeStorage::find(Task& task) {
	for (size_t i = 0 ; i < _tasks.size() ; ++i) {
		if (_tasks[i] == task) {
			return i;
		}
	}

	//if not found, return an invalid index
	return _tasks.size();
}

//return task reference object in _tasks based on index of _tasks
//index is base-0
Task& RunTimeStorage::getEntry(size_t index) {
	if (index >= _tasks.size()) {
		throw INDEX_NOT_FOUND_EXCEPTION(index);
	}

	return _tasks[index];
}

//add a task to runTimeStorage
//no duplicate task is allowed.
void RunTimeStorage::add(Task task) {
	if (isDuplicate(task)) {
		throw DUPLICATE_TASK_EXCEPTION(); 
	}
	_tasks.push_back(task);
	return;
}

//add a task into specified index in _tasks
//used for undo only as _entryOrder need to be maintained
void RunTimeStorage::insert(Task task, size_t index) {
	assert(!isDuplicate(task));
	_tasks.insert(_tasks.begin()+index, task);
	return;
}

void RunTimeStorage::removeLastEntry() {
	_tasks.pop_back();
	return;
}

bool RunTimeStorage::isDuplicate(Task task) {
	size_t n = _tasks.size();
	for (size_t i = 0 ; i < n ; ++i) {
		if (_tasks[i] == task) {
			return true;
		}
	}
	return false;
}

Task RunTimeStorage::remove(size_t index) {
	if (index > _tasksToDisplay.size()) {
		throw INDEX_NOT_FOUND_EXCEPTION(index);
	}

	Task taskToDelete = _tasksToDisplay[index-1];

	std::vector<Task>::iterator iter = std::find(_tasks.begin(),_tasks.end(), taskToDelete);

	_tasksToDisplay.erase(_tasksToDisplay.begin() + index - 1);
	_tasks.erase(iter);

	return taskToDelete;
}

void RunTimeStorage::removeEntry(size_t index) {
	if (index > _tasks.size()) {
		throw INDEX_NOT_FOUND_EXCEPTION(index);
	}

	_tasks.erase(_tasks.begin() + index);
}

void RunTimeStorage::removeAll(void) {
	if (_tasks.empty()) {
		throw EMPTY_STORAGE_EXCEPTION();
	}

	_tasks.clear();

	return;
}

Display_Type RunTimeStorage::getDisplayType() {
	return _displayMode;
}

void RunTimeStorage::changeDisplayType(Display_Type type) {
	_displayMode = type;
}

Sort_Type RunTimeStorage::getSortType() {
	return _sortMode;
}

void RunTimeStorage::changeSortType(Sort_Type type) {
	_sortMode = type;
}

bool RunTimeStorage::isValidForDisplay(Task task) {
	boost::posix_time::ptime startDateTime = task.getStartDateTime();
	boost::posix_time::ptime endDateTime = task.getEndDateTime();
	switch(_displayMode) {
	case Display_Type::displayFloat:
		return startDateTime.is_special() && endDateTime.is_special();
	case Display_Type::displayTimed:
		return !startDateTime.is_special() && !endDateTime.is_special();
	case Display_Type::displayTodo:
		return startDateTime.is_special() && !endDateTime.is_special();
	default:
		return true;
	}
}

bool RunTimeStorage::isValidIndex(size_t index) {
	if (index < _tasks.size()) {
		return true;
	} else {
		return false;
	}
}

void RunTimeStorage::reformTasksToDisplay() {
	_tasksToDisplay.clear();

	for (std::vector<Task>::iterator iter = _tasks.begin() ; iter != _tasks.end() ; ++iter) {
		if (isValidForDisplay(*iter)) {
			_tasksToDisplay.push_back(*iter);
		}
	}

	return;
}

//Pre-condition : TasksToDisplay is in sortByEntryOrder
//Post-condition: TasksToDisplay is sorted according to _sortMode
//              : The sort is stable
void RunTimeStorage::sortTasksToDisplay() {
	switch(_sortMode) {
	case Sort_Type::sortByEntryOrder:
		break;
	case Sort_Type::sortByName:
		std::stable_sort(_tasksToDisplay.begin(),_tasksToDisplay.end(),Task::sortByNameAscending);
		break;
	case Sort_Type::sortByStart:
		std::stable_sort(_tasksToDisplay.begin(),_tasksToDisplay.end(),Task::sortByStartDateTimeAscending);
		break;
	case Sort_Type::sortByEnd:
		std::stable_sort(_tasksToDisplay.begin(),_tasksToDisplay.end(),Task::sortByEndDateTimeAscending);
		break;
	case Sort_Type::sortByNameDesc:
		std::stable_sort(_tasksToDisplay.begin(),_tasksToDisplay.end(),Task::sortByNameDescending);
		break;
	case Sort_Type::sortByStartDesc:
		std::stable_sort(_tasksToDisplay.begin(),_tasksToDisplay.end(),Task::sortByStartDateTimeDescending);
		break;
	case Sort_Type::sortByEndDesc:
		std::stable_sort(_tasksToDisplay.begin(),_tasksToDisplay.end(),Task::sortByEndDateTimeDescending);
		break;
	}
	return;
}

void RunTimeStorage::updateDisplay() {
	reformTasksToDisplay();
	sortTasksToDisplay();
	return;
}

void RunTimeStorage::saveToFile() {
	try {
		_physicalStorageHandler->saveToFile(_tasks);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw e;
	} catch (INVALID_PATH_EXCEPTION e) {
		throw e;
	}
	return;
}

void RunTimeStorage::saveToFile(std::string filePath) {
	try {
		_physicalStorageHandler->saveToFile(_tasks, filePath);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw e;
	} catch (INVALID_PATH_EXCEPTION e) {
		throw e;
	}
	return;
}

void RunTimeStorage::loadFromFile() {
	try {
		_physicalStorageHandler->loadFromFile(_tasks);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw e;
	} catch (INVALID_PATH_EXCEPTION e) {
		throw e;
	}
	return;
}

void RunTimeStorage::loadFromFile(std::string filePath) {
	try {
		_physicalStorageHandler->loadFromFile(_tasks, filePath);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw e;
	} catch (INVALID_PATH_EXCEPTION e) {
		throw e;
	}
	return;
}

void RunTimeStorage::configureSaveLocation(std::string filePath) {
	try {
		_physicalStorageHandler->setSaveLocation(filePath);
	} catch (INVALID_FILE_EXCEPTION e) {
		throw e;
	} catch (INVALID_PATH_EXCEPTION e) {
		throw e;
	}
	return;
}

std::string RunTimeStorage::getFilePath() {
	return _physicalStorageHandler->getFilePath();
}
```
###### Logic\RunTimeStorage.h
``` h

#pragma once

#include <fstream>
#include <limits>
#include <algorithm>
#include "Task.h"
#include "UIFeedback.h"
#include "..\Parser\Parser.h"
#include "..\Storage\PhysicalStorageHandler.h"
#include "..\Logger\Logger.h"

using namespace API;

const std::string MESSAGE_DUPLICATE_TASK = "Duplicate task is found. No change is made.";
const std::string MESSAGE_EMPTY_STORAGE = "Storage is already empty. There is no task to delete.";
const std::string MESSAGE_INDEX_NOT_FOUND = "No task is found at index ";


enum Display_Type {
	displayAll,			//Display all tasks without filter
	displayFloat,		//Display only floating task
	displayTimed,		//Display only timed task
	displayTodo		//Display only todo task
};

enum Sort_Type {
	sortByEntryOrder,	//Sort tasks by entry order
	sortByName,			//Sort tasks by name in ascending order
	sortByStart,		//Sort tasks by start date time in ascending order
	sortByEnd,			//Sort tasks by end date time in ascending order
	sortByNameDesc,		//Sort tasks by name in descending order
	sortByStartDesc,	//Sort tasks by start date time in descending order
	sortByEndDesc		//Sort tasks by end date time in descending order
};

class INDEX_NOT_FOUND_EXCEPTION : public std::exception {
public:
	explicit INDEX_NOT_FOUND_EXCEPTION (const int index) : std::exception((MESSAGE_INDEX_NOT_FOUND + std::to_string(index)).c_str()) {
	}
};

class EMPTY_STORAGE_EXCEPTION : public std::exception {
public:
	explicit EMPTY_STORAGE_EXCEPTION () : std::exception(MESSAGE_EMPTY_STORAGE.c_str()) {
	}
};

class DUPLICATE_TASK_EXCEPTION : public std::exception {
public:
	explicit DUPLICATE_TASK_EXCEPTION() : std::exception(MESSAGE_DUPLICATE_TASK.c_str()) {
	}
};

class RunTimeStorage {
private:
	//_tasks is always sorted by Entry Order, the order of task being added
	std::vector<Task> _tasks;
	//_tasksToDisplay is filtered out from Tasks and sorted based on _displayMode and _sortMode
	std::vector<Task> _tasksToDisplay;

	PhysicalStorageHandler* _physicalStorageHandler;

	Display_Type _displayMode;
	Sort_Type _sortMode;

	//If the task fit _displayMode, return true, else return false
	bool isValidForDisplay(Task task);

	//Filter tasks from _tasks into _tasksToDisplay based on _displayMode
	void reformTasksToDisplay();

	//Sort _tasksToDisplay based on _sortMode
	void sortTasksToDisplay();

	//update TasksToDisplay based on _displayMode and _sortMode
	void updateDisplay();

public:
	RunTimeStorage();
	//return _tasks vector
	std::vector<Task>& getAllTasks();

	//return _tasksToDisplay vector
	std::vector<Task>& getTasksToDisplay();

	//update _tasksToDisplay and return the vector
	std::vector<Task>& refreshTasksToDisplay();

	//overwrite _tasksToDisplay with provided Task vector
	void setTasksToDisplay(std::vector<Task>);

	//add a task to _tasks vector at the end
	void add(Task task);

	//add a task to _tasks vector at index position provided.
	//If index is invalid, throw INDEX_NOT_FOUND_EXCEPTION
	void insert(Task task, size_t index);

	//remove task at the last position of _tasks
	void removeLastEntry();

	//remove task at the index position provided.
	//If index is invalid, throw INDEX_NOT_FOUND_EXCEPTION
	Task remove(size_t index);

	//remove task at the index position provided.
	//If index is invalid, throw INDEX_NOT_FOUND_EXCEPTION
	void removeEntry(size_t index);

	//remove all tasks in _tasks
	void removeAll();	

	//return the task in _tasksToDisplay based on index provided(1-based)
	//If index is invalid, throw INDEX_NOT_FOUND_EXCEPTION
	Task& find(size_t index);

	//return the index of task in _tasks (0-based)
	//if task is not found, return an invalid index which is size of _tasks
	size_t find(Task& task);

	//return the task in _tasks based on index provided (0-based)
	Task& getEntry(size_t index);

	//Check whether a duplicate task exist in _tasks
	bool isDuplicate(Task task);

	//Check whether an index is valid for _tasks or not
	bool isValidIndex(size_t index);

	Display_Type getDisplayType();
	void changeDisplayType(Display_Type type);
	Sort_Type getSortType();
	void changeSortType(Sort_Type type);

	void saveToFile();
	void saveToFile(std::string filePath);
	void loadFromFile();
	void loadFromFile(std::string filePath);
	void configureSaveLocation(std::string filePath);
	std::string getFilePath();
};
```
###### Logic\Task.cpp
``` cpp

#include "Task.h"
#include <string>
using namespace API;

TASK_EXCEPTION::TASK_EXCEPTION(std::string message) : std::exception(message.c_str()){
}

TAG_LIMIT_EXCEPTION::TAG_LIMIT_EXCEPTION() : TASK_EXCEPTION(MESSAGE_TAG_LIMIT_REACHED.c_str()) {
}

Task::Task() {
}

Task::Task(std::string taskText) {
	try {
		checkIsValidName(taskText);
	} catch (TASK_EXCEPTION e) {
		throw e;
	}
	_taskText = taskText;
	_isComplete = false;
}

Task::Task(std::string taskText, ptime endDateTime) {
	try {
		checkIsValidName(taskText);
	} catch (TASK_EXCEPTION e) {
		throw e;
	}
	_taskText = taskText;
	_endDateTime = endDateTime;
	_isComplete = false;
}

Task::Task(std::string taskText, ptime startDateTime, ptime endDateTime) {
	try {
		checkIsValidName(taskText);
	} catch (TASK_EXCEPTION e) {
		throw e;
	}

	if (isEndLessThanStart(startDateTime,endDateTime)) {
		throw TASK_EXCEPTION(MESSAGE_END_LESS_THAN_START.c_str());
	} else if (endDateTime.is_special() && !startDateTime.is_special()) {
		throw TASK_EXCEPTION(MESSAGE_EMPTY_END_DATE.c_str());
	}

	_taskText = taskText;
	_startDateTime = startDateTime;
	_endDateTime = endDateTime;
	_isComplete = false;
}

bool Task::isValid() {
	return _taskText.size() > 0;
}

std::string Task::getTaskText() {
	return _taskText;
}

ptime Task::getStartDateTime() {
	return _startDateTime;
}

ptime Task::getEndDateTime() {
	return _endDateTime;
}

std::set<std::string>& Task::getTags(){
	return _tags;
}

bool Task::operator== (Task another) {
	if (this->_taskText != another._taskText) {
		return false;
	} else if (this->_startDateTime != another._startDateTime) {
		return false;
	} else if (this->_endDateTime != another._endDateTime) {
		return false;
	} else if (this->getTags() != another.getTags()) {
		return false;
	} else {
		return true;
	}
}

bool Task::isComplete(){
	return _isComplete;
}

bool Task::isEndLessThanStart(ptime start, ptime end) {
	if (start.is_special()) {
		return false;
	} else if (end.is_special()) {
		return false;
	} else {
		return end < start;
	}
}

void Task::checkIsValidName(std::string name) {
	if (name.empty()) {
		throw TASK_EXCEPTION(MESSAGE_EMPTY_TASK_TEXT.c_str());
	} else if (!std::isalnum(name[0])) {
		throw TASK_EXCEPTION(MESSAGE_INVALID_FIRST_CHARACTER.c_str());
	} else if (name.size() > MAX_TASK_NAME_LENGTH) {
		throw TASK_EXCEPTION(MESSAGE_LONG_TASK_TEXT.c_str());
	}
	return;
}

void Task::toggleComplete() {
	_isComplete = !_isComplete;
}

void Task::changeTaskText(std::string newTaskText) {
	try{
		checkIsValidName(newTaskText);
		_taskText = newTaskText;
	} catch (TASK_EXCEPTION e) {
		throw e;
	}
}

void Task::changeStartDateTime(ptime newStartDateTime) {
	if (isEndLessThanStart(newStartDateTime,_endDateTime)) {
		throw TASK_EXCEPTION(MESSAGE_END_LESS_THAN_START);
	} else if (!newStartDateTime.is_special() && _endDateTime.is_special()) {
		throw TASK_EXCEPTION(MESSAGE_EMPTY_END_DATE);
	}

	_startDateTime = newStartDateTime;
}

void Task::changeEndDateTime(ptime newEndDateTime) {
	if (isEndLessThanStart(_startDateTime,newEndDateTime)) {
		throw TASK_EXCEPTION(MESSAGE_END_LESS_THAN_START);
	} else if (newEndDateTime.is_special() && !_startDateTime.is_special()) {
		throw TASK_EXCEPTION(MESSAGE_EMPTY_END_DATE);
	}

	_endDateTime = newEndDateTime;
}

void Task::addTag(std::string tag) {
	if (_tags.size() == MAX_TAG_NUM) {
		throw TAG_LIMIT_EXCEPTION();
	} else if (tag.size() > MAX_TAG_LENGTH) {
		throw TASK_EXCEPTION(MESSAGE_LONG_TAG);
	} else if (tag[0] != '#') {
		throw TASK_EXCEPTION(MESSAGE_TAG_FIRST_CHARACTER_NOT_HASH);
	}else if (_tags.find(tag) != _tags.end()) {
		char buffer[255];
		sprintf_s(buffer, MESSAGE_DUPLICATE_TAG.c_str(), tag.c_str());
		throw TASK_EXCEPTION(buffer);
	} else {
		_tags.insert(tag);
		return;
	}
}

void Task::removeTag(std::string tag) {
	std::set<std::string>::iterator iter = _tags.find(tag);
	if (iter == _tags.end()) {
		char buffer[255];
		sprintf_s(buffer, MESSAGE_TAG_NOT_FOUND.c_str(), tag.c_str());
		throw TASK_EXCEPTION(buffer);
	} else {
		_tags.erase(iter);
	}
}

bool Task::sortByStartDateTimeAscending (Task task1, Task task2) {
	boost::posix_time::ptime startDateTime1 = task1.getStartDateTime();
	boost::posix_time::ptime startDateTime2 = task2.getStartDateTime();

	if (startDateTime1.is_special() && startDateTime2.is_special()) {
		return false;
	} else if (startDateTime1.is_special()) {
		return false;
	} else if (startDateTime2.is_special()) {
		return true;
	} else {
		return startDateTime1 < startDateTime2;
	}
}

bool Task::sortByEndDateTimeAscending (Task task1, Task task2) {
	boost::posix_time::ptime endDateTime1 = task1.getEndDateTime();
	boost::posix_time::ptime endDateTime2 = task2.getEndDateTime();

	if (endDateTime1.is_special() && endDateTime2.is_special()) {
		return false;
	} else if (endDateTime1.is_special()) {
		return false;
	} else if (endDateTime2.is_special()) {
		return true;
	} else {
		return endDateTime1 < endDateTime2;
	}
}

bool Task::sortByNameAscending (Task task1, Task task2) {
	std::string task1Text = task1.getTaskText();
	std::string task2Text = task2.getTaskText();

	size_t minStringLength = (std::min)(task1Text.size(), task2Text.size());

	for (size_t i = 0 ; i < minStringLength ; ++i) {
		task1Text[i] = std::tolower(task1Text[i]);
		task2Text[i] = std::tolower(task2Text[i]);
	}

	for (size_t i = 0 ; i < minStringLength ; ++i) {
		if (task1Text[i] < task2Text[i]) {
			return true;
		} else if (task1Text[i] > task2Text[i]) {
			return false;
		}
	}

	if (task1Text.size() < task2Text.size()) {
		return true;
	} else {
		return false;
	}
}

bool Task::sortByStartDateTimeDescending (Task task1, Task task2) {
	boost::posix_time::ptime startDateTime1 = task1.getStartDateTime();
	boost::posix_time::ptime startDateTime2 = task2.getStartDateTime();

	if (startDateTime1.is_special() && startDateTime2.is_special()) {
		return false;
	} else if (startDateTime1.is_special()) {
		return false;
	} else if (startDateTime2.is_special()) {
		return true;
	} else {
		return startDateTime1 > startDateTime2;
	}		
}

bool Task::sortByEndDateTimeDescending (Task task1, Task task2) {
	boost::posix_time::ptime endDateTime1 = task1.getEndDateTime();
	boost::posix_time::ptime endDateTime2 = task2.getEndDateTime();

	if (endDateTime1.is_special() && endDateTime2.is_special()) {
		return false;
	} else if (endDateTime1.is_special()) {
		return false;
	} else if (endDateTime2.is_special()) {
		return true;
	} else {
		return endDateTime1 > endDateTime2;
	}
}

bool Task::sortByNameDescending(Task task1, Task task2) {
	std::string task1Text = task1.getTaskText();
	std::string task2Text = task2.getTaskText();

	size_t minStringLength = (std::min)(task1Text.size(), task2Text.size());

	for (size_t i = 0 ; i < minStringLength ; ++i) {
		task1Text[i] = std::tolower(task1Text[i]);
		task2Text[i] = std::tolower(task2Text[i]);
	}

	for (size_t i = 0 ; i < minStringLength ; ++i) {
		if (task1Text[i] > task2Text[i]) {
			return true;
		} else if (task1Text[i] < task2Text[i]) {
			return false;
		}
	}

	if (task1Text.size() < task2Text.size()) {
		return true;
	} else {
		return false;
	}	
}
```
###### Logic\Task.h
``` h

#pragma once

// TODO this include may not belong here, move it
#include <set>
#include "../boost/date_time/posix_time/posix_time.hpp"

typedef class boost::posix_time::ptime ptime;

const std::string MESSAGE_EMPTY_TASK_TEXT = "Task text cannot be empty.";
const std::string MESSAGE_LONG_TASK_TEXT = "Task text cannot be more than 128 characters long.";
const std::string MESSAGE_INVALID_FIRST_CHARACTER = "First character of task text has to be alphanumeric.";
const std::string MESSAGE_END_LESS_THAN_START = "Start date time must be before end date time.";
const std::string MESSAGE_EMPTY_END_DATE = "When start date time is a defined date-time, end date time cannot be not a date time.";
const std::string MESSAGE_DUPLICATE_TAG = "%s already exist, tag cannot be added.";
const std::string MESSAGE_TAG_NOT_FOUND = "%s not found, tag cannot be removed.";
const std::string MESSAGE_TAG_LIMIT_REACHED = "Maximum no. of tag has been reached, no more tag can be added.";
const std::string MESSAGE_LONG_TAG = "Length of tag cannot be more than 32 (Including #).";
const std::string MESSAGE_TAG_FIRST_CHARACTER_NOT_HASH = "First character of tag must be \'#\'";

const int MAX_TASK_NAME_LENGTH = 128;
const int MAX_TAG_LENGTH = 32;
const int MAX_TAG_NUM = 5;

class TASK_EXCEPTION : public std::exception {
public:
	explicit TASK_EXCEPTION(std::string message);
};

class TAG_LIMIT_EXCEPTION : public TASK_EXCEPTION {
public:
	explicit TAG_LIMIT_EXCEPTION();
};

namespace API{
class Task
{
public:
	//Constructor for invalid task
	Task();

	//Constructor for floating task
	Task(std::string taskText);

	//Constructor for toDo task
	Task(std::string taskText, ptime endDateTime);

	//Constructor for timed task
	Task(std::string taskText, ptime startDateTime, ptime endDateTime);

	//Getters
	std::string getTaskText();
	ptime getStartDateTime();
	ptime getEndDateTime();
	std::set<std::string>& getTags();

	//Methods
	bool operator==(Task another);
	bool isValid();
	bool isComplete();

	//Modifiers
	void changeTaskText(std::string newTaskText);
	void changeStartDateTime(ptime newStartDateTime);
	void changeEndDateTime(ptime newEndDateTime);
	void toggleComplete();
	void addTag(std::string);
	void removeTag(std::string);

	//comparator functions for sorting
	static bool sortByStartDateTimeAscending (Task task1, Task task2);
	static bool sortByEndDateTimeAscending (Task task1, Task task2);
	static bool sortByNameAscending (Task task1, Task task2);
	static bool sortByStartDateTimeDescending (Task task1, Task task2);
	static bool sortByEndDateTimeDescending (Task task1, Task task2);
	static bool sortByNameDescending(Task task1, Task task2);

private:
	std::string _taskText;
	ptime _startDateTime;
	ptime _endDateTime;
	bool _isComplete;
	std::set<std::string> _tags; 

	static bool isEndLessThanStart(ptime start, ptime end);
	static void checkIsValidName(std::string name);
};
}
```
###### Logic\UIFeedback.cpp
``` cpp

#include "UIFeedback.h"

UIFeedback::UIFeedback() {
	_feedbackMessage = "";
}

UIFeedback::UIFeedback(std::vector<Task>& tasksForDisplay, std::string feedbackMessage) {
	_tasksForDisplay = tasksForDisplay;
	_feedbackMessage = feedbackMessage;
}

std::vector<Task>& UIFeedback::getTasksForDisplay() {
	return _tasksForDisplay;
}

std::string UIFeedback::getFeedbackMessage() {
	return _feedbackMessage;
}
```
###### Logic\UIFeedback.h
``` h

#pragma once

#include <vector>
#include "Task.h"
using namespace API;

class UIFeedback{
private:
	std::vector<Task> _tasksForDisplay;
	std::string _feedbackMessage;
public:
	UIFeedback();
	UIFeedback(std::vector<Task>& tasksForDisplay, std::string feedbackMessage);

	std::vector<Task>& getTasksForDisplay();
	std::string getFeedbackMessage();
};
```
###### LogicTest\LogicTest.cpp
``` cpp

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace LogicTest {
	TEST_CLASS(CommandCreatorTest) {
public:

	TEST_METHOD(testCreateAddFloatCommand) {
		CommandCreator creator;

		CommandTokens token;

		//normal case
		token.setPrimaryCommand(CommandTokens::Add);
		token.setSecondaryCommand(CommandTokens::Floating);
		token.setTaskName(std::string("do something"));
		AddCommand* command = creator.testProcessAddCommand(token);
		Task task("do something");
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::PrimaryCommandType::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::SecondaryCommandType::Floating);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == task);

		//empty string case
		token.setTaskName(std::string(""));

		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false,true);  //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_EMPTY_TASK_TEXT.c_str(), e.what());
		}

		//String length = 150 which is character limit of task text.
		//Upper boundary of valid region.
		std::string testString = "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
		token.setTaskName(testString);

		Assert::AreEqual((size_t)128, testString.size());

		command = creator.testProcessAddCommand(token);
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::PrimaryCommandType::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::SecondaryCommandType::Floating);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == Task(testString));

		//Smaller character no. that exceed character limit
		testString += "1";
		Assert::AreEqual((size_t)129, testString.size());

		token.setTaskName(testString);

		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false,true);  //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_LONG_TASK_TEXT.c_str(), e.what());
		}

	}

	TEST_METHOD(testCreateAddTodoCommand) {
		CommandCreator creator;
		CommandTokens token;

		//normal case
		std::string taskName = "do something";
		std::string timeString("2002-01-20 23:59:59.000");
		token.setPrimaryCommand(CommandTokens::Add);
		token.setSecondaryCommand(CommandTokens::By);
		token.setTaskName(taskName);
		token.setEndDateTime(boost::posix_time::time_from_string(timeString));

		AddCommand* command = creator.testProcessAddCommand(token);
		Task task("do something", boost::posix_time::time_from_string(timeString));
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::By);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == task);

		//empty string case
		token.setTaskName(std::string(""));

		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false,true);  //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_EMPTY_TASK_TEXT.c_str(), e.what());
		}

		//String length = 150 which is character limit of task text.
		//Upper boundary of valid region.
		std::string testString = "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
		token.setTaskName(testString);

		Assert::AreEqual((size_t)128, testString.size());

		command = creator.testProcessAddCommand(token);
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::PrimaryCommandType::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::SecondaryCommandType::By);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == Task(testString, boost::posix_time::time_from_string(timeString)));

		//Smaller character no. that exceed character limit
		testString += "1";
		Assert::AreEqual((size_t)129, testString.size());

		token.setTaskName(testString);

		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false,true);  //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_LONG_TASK_TEXT.c_str(), e.what());
		}
	}

	TEST_METHOD(testCreateAddTimedCommand) {
		CommandCreator creator;
		CommandTokens token;

		//normal case
		std::string taskName = "do something";
		std::string timeString1("2002-01-20 23:59:59");
		std::string timeString2("2002-01-21 23:59:59");
		token.setPrimaryCommand(CommandTokens::Add);
		token.setSecondaryCommand(CommandTokens::FromTo);
		token.setTaskName(taskName);
		token.setStartDateTime(boost::posix_time::time_from_string(timeString1));
		token.setEndDateTime(boost::posix_time::time_from_string(timeString2));

		AddCommand* command = creator.testProcessAddCommand(token);
		Task task("do something", boost::posix_time::time_from_string(timeString1), boost::posix_time::time_from_string(timeString2));
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::FromTo);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == task);

		//empty string case
		token.setTaskName(std::string(""));

		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false,true);  //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_EMPTY_TASK_TEXT.c_str(), e.what());
		}

		//String length = 150 which is character limit of task text.
		//Upper boundary of valid region.
		std::string testString = "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
		token.setTaskName(testString);

		Assert::AreEqual((size_t)128, testString.size());

		command = creator.testProcessAddCommand(token);
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::PrimaryCommandType::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::SecondaryCommandType::FromTo);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == Task(testString, boost::posix_time::time_from_string(timeString1), boost::posix_time::time_from_string(timeString2)));

		//Smaller character no. that exceed character limit
		testString += "1";
		Assert::AreEqual((size_t)129, testString.size());

		token.setTaskName(testString);

		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false,true);  //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_LONG_TASK_TEXT.c_str(), e.what());
		}

		//boundary case where startDateTime is equals to endDateTime
		//still allowed
		testString = testString.substr(0,128);
		token.setTaskName(testString);
		token.setStartDateTime(boost::posix_time::time_from_string(timeString2));
		
		command = creator.testProcessAddCommand(token);
		Assert::AreEqual(true, command->getPrimaryCommandType() == CommandTokens::PrimaryCommandType::Add);
		Assert::AreEqual(true, command->getSecondaryCommandType() == CommandTokens::SecondaryCommandType::FromTo);
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(true, command->getTask() == Task(testString, boost::posix_time::time_from_string(timeString2), boost::posix_time::time_from_string(timeString2)));

		//endDateTime is less than startDateTime
		//not allowed
		token.setEndDateTime(boost::posix_time::time_from_string(timeString1));
		try {
			command = creator.testProcessAddCommand(token);
			Assert::AreEqual(false, true); //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_END_LESS_THAN_START.c_str(), e.what());
		}

	}

	TEST_METHOD(testCreateDeleteIndexCommand) {
		CommandCreator creator;
		CommandTokens token;
		token.setPrimaryCommand(CommandTokens::Delete);
		token.setSecondaryCommand(CommandTokens::Index);

		DeleteIndexCommand* command;

		token.setIndex(1);
		command = creator.testProcessDeleteIndexCommand(token);
		Assert::AreEqual(true , CommandTokens::Delete==command->getPrimaryCommandType());
		Assert::AreEqual(true , CommandTokens::Index==command->getSecondaryCommandType());
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(size_t(1), command->getIndex());

		//Invalid case
		token.setIndex(0);
		try {
			command = creator.testProcessDeleteIndexCommand(token);
			Assert::AreEqual(false,true); //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_NON_POSITIVE_INDEX.c_str(), e.what());
		}
	}

	TEST_METHOD(testCreateDeleteBeforeCommand) {
		CommandCreator creator;
		CommandTokens token;
		token.setPrimaryCommand(CommandTokens::Delete);
		token.setSecondaryCommand(CommandTokens::By);

		DeleteBeforeCommand* command = NULL;

		std::string timeString("2002-01-20 23:59:59");
		std::string expectedString("2002-Jan-20 23:59:59");
		boost::posix_time::ptime endTime = boost::posix_time::time_from_string(timeString);

		token.setEndDateTime(endTime);
		command = creator.testProcessDeleteBeforeCommand(token);
		Assert::AreEqual(true , CommandTokens::Delete==command->getPrimaryCommandType());
		Assert::AreEqual(true , CommandTokens::By==command->getSecondaryCommandType());
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(expectedString.c_str(), boost::posix_time::to_simple_string(command->getEndDateTime()).c_str());

		token.setEndDateTime(boost::posix_time::ptime());
		try {
			command = creator.testProcessDeleteBeforeCommand(token);
			Assert::AreEqual(false, true); //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_INVALID_DATE_TIME.c_str(), e.what());
		}
	}

	TEST_METHOD(testCreateDeleteFromToCommand) {
		CommandCreator creator;
		CommandTokens token;
		token.setPrimaryCommand(CommandTokens::Delete);
		token.setSecondaryCommand(CommandTokens::FromTo);

		DeleteFromToCommand* command = NULL;

		std::string timeString1("2002-01-20 23:59:59");
		std::string timeString2("2002-01-21 23:59:59");
		std::string expectedString1("2002-Jan-20 23:59:59");
		std::string expectedString2("2002-Jan-21 23:59:59");
		boost::posix_time::ptime startTime = boost::posix_time::time_from_string(timeString1);
		boost::posix_time::ptime endTime = boost::posix_time::time_from_string(timeString2);

		token.setStartDateTime(startTime);
		token.setEndDateTime(endTime);
		command = creator.testProcessDeleteFromToCommand(token);
		Assert::AreEqual(true , CommandTokens::Delete==command->getPrimaryCommandType());
		Assert::AreEqual(true , CommandTokens::FromTo==command->getSecondaryCommandType());
		Assert::AreEqual(false, command->isExecuted());
		Assert::AreEqual(expectedString1.c_str(), boost::posix_time::to_simple_string(command->getStartDateTime()).c_str());
		Assert::AreEqual(expectedString2.c_str(), boost::posix_time::to_simple_string(command->getEndDateTime()).c_str());

		//startTime cannot be more than endTime, thus exception should be thrown.
		token.setEndDateTime(startTime);
		token.setStartDateTime(endTime);
		try {
			command = creator.testProcessDeleteFromToCommand(token);
			Assert::AreEqual(false, true); //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_END_LESS_THAN_START.c_str(), e.what());
		}

		//endDateTime is not a date time, exception should be thrown.
		token.setStartDateTime(startTime);
		token.setEndDateTime(boost::posix_time::ptime());
		try {
			command = creator.testProcessDeleteFromToCommand(token);
			Assert::AreEqual(false, true); //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_INVALID_DATE_TIME.c_str(), e.what());
		}

		//startDateTime is not a date time, exception should be thrown.
		token.setStartDateTime(boost::posix_time::ptime());
		token.setEndDateTime(endTime);
		try {
			command = creator.testProcessDeleteFromToCommand(token);
			Assert::AreEqual(false, true); //expect exception thrown to skip this line.
		} catch (std::exception e) {
			Assert::AreEqual(MESSAGE_INVALID_DATE_TIME.c_str(), e.what());
		}
	}

	TEST_METHOD (testCreateDeleteAllCommand) {
		CommandCreator creator;
		CommandTokens token;
		token.setPrimaryCommand(CommandTokens::Delete);
		token.setSecondaryCommand(CommandTokens::All);

		DeleteAllCommand* command = NULL;

		command = creator.testProcessDeleteAllCommand(token);
		Assert::AreEqual(true , CommandTokens::Delete==command->getPrimaryCommandType());
		Assert::AreEqual(true , CommandTokens::All==command->getSecondaryCommandType());
		Assert::AreEqual(false, command->isExecuted());	
	}
	};
}
```
