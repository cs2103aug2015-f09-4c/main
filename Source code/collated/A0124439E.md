# A0124439E
###### IntegrationTest\IntegrationTest.cpp
``` cpp
// This project is the testing of the components working together
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

// All these const strings are declared because they are reused in multiple tests
const std::string CMD_ADD = "AdD";
const std::string CMD_COMPLETE = "CoMpLeTe";
const std::string CMD_DELETE = "DeLeTe";
const std::string CMD_DELETE_ALL = "DeLeTe AlL";
const std::string CMD_DELETE_COMPLETED = "DeLeTe CoMpLeTeD";
const std::string CMD_EDIT_NAME = "EdIt NaMe";
const std::string CMD_EDIT_START = "EdIt StArT";
const std::string CMD_EDIT_END = "EdIt EnD";
const std::string CMD_SEARCH = "SeArCh";
const std::string CMD_TAG = "TaG";
const std::string CMD_UNDO = "UnDo";
const std::string CMD_UNTAG = "UnTaG";
const std::string CMD_REFRESH = "refresh";

// Feedback 'ERROR' messages when Swiftask knows something is wrong and the command is not executed.
const std::string CMD_INVALID = "Invalid Command. No change is made.";
const std::string CMD_DUPLICATE = "Duplicate task is found. No change is made.";
const std::string UNKNOWN_EXCEPTION = "Unknown exception";
const std::string ONLY_POSITIVE = "Only positive index is allowed. No change is made.";
const std::string TASK_NOT_FOUND_AT = "No task is found at index ";
const std::string MAX_TAGS = "Maximum no. of tag has been reached, no more tag can be added.";
const std::string NO_TASKS_WITH_CONDITION = "No task suited the condition is found. No task is deleted.";

// These strings have spaces behind as a date is expected to be given.
const std::string BY = "By ";
const std::string FROM = "From ";
const std::string TO = "To ";

const std::string SPACE = " ";

const std::string TASK_A = "TASK A"; 
const std::string TASK_B = "TASK B";
const std::string TASK_C = "TASK C";
const std::string TASK_D = "TASK D";
const std::string TASK_E = "TASK E";
const std::string TASK_F = "TASK F";

const std::string NOT_A_DATE_TIME = "not-a-date-time";
const std::string DATE_TIME_1_BEFORE = "2015-Oct-10 15:59:00";
const std::string DATE_TIME_1 = "2015-Oct-10 16:00:00";
const std::string DATE_TIME_1_AFTER = "2015-Oct-10 16:01:00";
const std::string DATE_TIME_2_BEFORE = "2015-Oct-10 17:59:00";
const std::string DATE_TIME_2 = "2015-Oct-10 18:00:00";
const std::string DATE_TIME_2_AFTER = "2015-Oct-10 18:01:00";
const std::string DATE_TIME_3_BEFORE = "2015-Oct-10 19:59:00";
const std::string DATE_TIME_3 = "2015-Oct-10 20:00:00";
const std::string DATE_TIME_3_AFTER = "2015-Oct-10 20:01:00";

const std::string TAG_A = "#TAG_A";
const std::string TAG_B = "#TAG_B";
const std::string TAG_C = "#TAG_C";
const std::string TAG_D = "#TAG_D";
const std::string TAG_E = "#TAG_E";
const std::string TAG_F = "#TAG_F";
const std::string TAG_WITHSPACE = "#TAG hasSpace";

// Valid add commands that will be used by test methods
const std::string ADD_COMMAND_1 = CMD_ADD + SPACE + TASK_A;
const std::string ADD_COMMAND_2 = CMD_ADD + SPACE + TASK_B + SPACE + BY + DATE_TIME_1;
const std::string ADD_COMMAND_3 = CMD_ADD + SPACE + TASK_C + SPACE + FROM + DATE_TIME_2 + SPACE + TO + DATE_TIME_3;

namespace UnitIntegrationTest {		
	TEST_CLASS(UnitIntegrationTest) {
public:

	TEST_METHOD(integrationAdd) {
		// Important to do it here because logic keeps a copy of data on construction
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;
		API::Task task;

		// Valid add commands
		// const std::string declared in the global scope

		// Invalid add commands
		// Not expecting to catch a bug

		// Testing add floating tasks in valid partition
		feedback = logic.executeCommand(ADD_COMMAND_1);
		task = feedback.getTasksForDisplay()[0];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreNotEqual(CMD_DUPLICATE, feedback.getFeedbackMessage());
		Assert::AreEqual(TASK_A, task.getTaskText());

		// Testing add tasks by deadline in valid partition
		feedback = logic.executeCommand(ADD_COMMAND_2);
		task = feedback.getTasksForDisplay()[1];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreNotEqual(CMD_DUPLICATE, feedback.getFeedbackMessage());
		Assert::AreEqual(TASK_B, task.getTaskText());
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing add tasks with duration in valid partition
		feedback = logic.executeCommand(ADD_COMMAND_3);
		task = feedback.getTasksForDisplay()[2];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreNotEqual(CMD_DUPLICATE, feedback.getFeedbackMessage());
		Assert::AreEqual(TASK_C, task.getTaskText());
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_3, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing add duplicates in invalid partition
		try {
			feedback = logic.executeCommand(ADD_COMMAND_1);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(CMD_DUPLICATE, e);
		}

		Assert::AreEqual((size_t) 3, feedback.getTasksForDisplay().size());
	}

	TEST_METHOD(integrationRefresh) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;

		// Testing refresh at lower bound of valid parition
		feedback = logic.executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 0, feedback.getTasksForDisplay().size());

		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);

		// Testing refresh in the valid partition when there are tasks
		feedback = logic.executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 3, feedback.getTasksForDisplay().size());
	}

	TEST_METHOD(integrationEdit) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;
		API::Task task;

		// Valid edit commands
		std::string editCommand1 = CMD_EDIT_NAME + " 1 " + TASK_D;
		std::string editCommand2 = CMD_EDIT_END + " 2 " + DATE_TIME_3;
		std::string editCommand3 = CMD_EDIT_START + " 3 " + DATE_TIME_1;

		// Invalid edit commands
		std::string editCommand0 = CMD_EDIT_END + " 0 " + DATE_TIME_2;
		std::string editCommand4 = CMD_EDIT_START + " 4 " + DATE_TIME_1;

		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);

		// Testing edit name and lower bound of valid partition
		feedback = logic.executeCommand(editCommand1);
		task = feedback.getTasksForDisplay()[0];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual(TASK_D, task.getTaskText());

		// Testing edit end date-time and in valid partition
		feedback = logic.executeCommand(editCommand2);
		task = feedback.getTasksForDisplay()[1];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual(DATE_TIME_3, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing edit start date-time and upper bound of valid partition
		feedback = logic.executeCommand(editCommand3);
		task = feedback.getTasksForDisplay()[2];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getStartDateTime()));

		// Testing index upper bound of invalid partition that is smaller than valid partition
		try {
			feedback = logic.executeCommand(editCommand0);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(ONLY_POSITIVE, e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		task = feedback.getTasksForDisplay()[0];
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing index lower bound of invalid partition that is larger than valid range partition
		try {
			feedback = logic.executeCommand(editCommand4);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(TASK_NOT_FOUND_AT + "4", e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		task = feedback.getTasksForDisplay()[2];
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getStartDateTime()));

	}

	TEST_METHOD(integrationTagUntag) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;
		std::set<std::string> tags;
		std::set<std::string>::iterator it;

		// Testing tag/untag commands
		std::string tagCommand1A = CMD_TAG + " 1 " + TAG_A;
		std::string tagCommand1B = CMD_TAG + " 1 " + TAG_B;
		std::string tagCommand1C = CMD_TAG + " 1 " + TAG_C;
		std::string tagCommand1D = CMD_TAG + " 1 " + TAG_D;
		std::string tagCommand1E = CMD_TAG + " 1 " + TAG_E;
		std::string tagCommand1F = CMD_TAG + " 1 " + TAG_F;
		std::string tagCommand3 = CMD_TAG + " 3 " + TAG_A;
		std::string tagCommand0 = CMD_TAG + " 0 " + TAG_A;
		std::string tagCommand4 = CMD_TAG + " 4 " + TAG_A;
		std::string tagCommand1Space = CMD_TAG + " 1 " + TAG_WITHSPACE;

		std::string untagCommand1A = CMD_UNTAG + " 1 " + TAG_A;
		std::string untagCommand3 = CMD_UNTAG + " 3 " + TAG_A;
		std::string untagCommand0 = CMD_UNTAG + " 0 " + TAG_A;
		std::string untagCommand4 = CMD_UNTAG + " 4 " + TAG_A; 

		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);

		// Tag Tests
		// Testing tag lower bound of valid partition
		feedback = logic.executeCommand(tagCommand1A);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, tags.size());
		Assert::AreEqual(TAG_A, *tags.begin());

		// Testing tags with space in invalid format partition
		try {
			feedback = logic.executeCommand(tagCommand1Space);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(CMD_INVALID, e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, tags.size());
		Assert::AreEqual(TAG_A, *tags.begin());

		// Testing tagging up to the maximum of 5 tags in a task in the valid partition
		feedback = logic.executeCommand(tagCommand1B);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 2, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_A, *it);
		Assert::AreEqual(TAG_B, *(++it));

		feedback = logic.executeCommand(tagCommand1C);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 3, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_A, *it);
		Assert::AreEqual(TAG_B, *(++it));
		Assert::AreEqual(TAG_C, *(++it));

		feedback = logic.executeCommand(tagCommand1D);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 4, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_A, *it);
		Assert::AreEqual(TAG_B, *(++it));
		Assert::AreEqual(TAG_C, *(++it));
		Assert::AreEqual(TAG_D, *(++it));

		feedback = logic.executeCommand(tagCommand1E);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 5, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_A, *it);
		Assert::AreEqual(TAG_B, *(++it));
		Assert::AreEqual(TAG_C, *(++it));
		Assert::AreEqual(TAG_D, *(++it));
		Assert::AreEqual(TAG_E, *(++it));


		// Testing 6th tags in a task in the lower bound of invalid partition that is larger than valid partition
		try {
			feedback = logic.executeCommand(tagCommand1F);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(MAX_TAGS, e);
		}

		// Testing tag upper bound of valid partition
		feedback = logic.executeCommand(tagCommand3);
		tags = feedback.getTasksForDisplay()[2].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, tags.size());
		Assert::AreEqual(TAG_A, *tags.begin());

		// Testing tag upper bound of invalid partition that is smaller than valid partition
		try {
			feedback = logic.executeCommand(tagCommand0);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(ONLY_POSITIVE, e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 5, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_A, *it);
		Assert::AreEqual(TAG_B, *(++it));
		Assert::AreEqual(TAG_C, *(++it));
		Assert::AreEqual(TAG_D, *(++it));
		Assert::AreEqual(TAG_E, *(++it));

		// Testing tag lower bound of invalid partition that is larger than valid partition
		try {
			feedback = logic.executeCommand(tagCommand4);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(TASK_NOT_FOUND_AT + "4", e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		tags = feedback.getTasksForDisplay()[2].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, tags.size());
		Assert::AreEqual(TAG_A, *tags.begin());

		// Untag Tests
		// Testing untag lower bound of valid partition
		feedback = logic.executeCommand(untagCommand1A);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 4, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_B, *it);
		Assert::AreEqual(TAG_C, *(++it));
		Assert::AreEqual(TAG_D, *(++it));
		Assert::AreEqual(TAG_E, *(++it));

		// Testing untag upper bound of valid partition
		feedback = logic.executeCommand(untagCommand3);
		tags = feedback.getTasksForDisplay()[2].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 0, tags.size());

		// Testing untag upper bound of invalid partition that is smaller than valid partition
		try {
			feedback = logic.executeCommand(untagCommand0);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(ONLY_POSITIVE, e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		tags = feedback.getTasksForDisplay()[0].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 4, tags.size());
		it = tags.begin();
		Assert::AreEqual(TAG_B, *it);
		Assert::AreEqual(TAG_C, *(++it));
		Assert::AreEqual(TAG_D, *(++it));
		Assert::AreEqual(TAG_E, *(++it));

		// Testing untag lower bound of invalid partition that is larger than valid partition
		try {
			feedback = logic.executeCommand(tagCommand4);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(TASK_NOT_FOUND_AT + "4", e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		tags = feedback.getTasksForDisplay()[2].getTags();

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 0, tags.size());
	}

	TEST_METHOD(integrationComplete) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;

		// Testing complete commands
		std::string completeCommand0 = CMD_COMPLETE + SPACE + "0";
		std::string completeCommand1 = CMD_COMPLETE + SPACE + "1";
		std::string completeCommand3 = CMD_COMPLETE + SPACE + "3";
		std::string completeCommand4 = CMD_COMPLETE + SPACE + "4";

		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);

		// Testing complete lower bound of valid partition
		feedback = logic.executeCommand(completeCommand1);

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual(true, feedback.getTasksForDisplay()[0].isComplete());

		// Testing complete upper bound of valid partition
		feedback = logic.executeCommand(completeCommand3);

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual(true, feedback.getTasksForDisplay()[2].isComplete());

		// Testing complete upper bound of invalid partition that is smaller than valid partition
		try {
			feedback = logic.executeCommand(completeCommand0);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(ONLY_POSITIVE, e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		Assert::AreEqual(true, feedback.getTasksForDisplay()[0].isComplete());

		// Testing complete lower bound of invalid partition that is larger than valid partition
		try {
			feedback = logic.executeCommand(completeCommand4);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(TASK_NOT_FOUND_AT + "4", e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		Assert::AreEqual(true, feedback.getTasksForDisplay()[2].isComplete());

	}

	TEST_METHOD(integrationDeleteIndex) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;
		API::Task task;

		// Testing delete commands
		std::string deleteCommand0 = CMD_DELETE + SPACE + "0";
		std::string deleteCommand1 = CMD_DELETE + SPACE + "1";
		std::string deleteCommand2 = CMD_DELETE + SPACE + "2";

		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);

		// Testing delete task within valid parition
		// May be trivial but leads to testing of deleting only one task
		feedback = logic.executeCommand(deleteCommand2);
		task = feedback.getTasksForDisplay()[1];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 2, feedback.getTasksForDisplay().size());
		Assert::AreEqual(TASK_C, task.getTaskText());
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_3, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing delete upper bound of valid partition
		feedback = logic.executeCommand(deleteCommand2);
		task = feedback.getTasksForDisplay()[0];

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing index lower bound of invalid partition that is larger than valid partition
		try {
			feedback = logic.executeCommand(deleteCommand2);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(TASK_NOT_FOUND_AT + "2", e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		task = feedback.getTasksForDisplay()[0];
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing index upper bound of invalid partition that is smaller than valid partition
		try {
			feedback = logic.executeCommand(deleteCommand0);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(ONLY_POSITIVE, e);
		}

		feedback = logic.executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing delete lower bound of valid partition and delete the only task
		feedback = logic.executeCommand(deleteCommand1);

		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 0, feedback.getTasksForDisplay().size());

		// Not worth testing deleting empty because it is part of the invalid partitions
	}

	TEST_METHOD(integrationDateTimeFormat) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		// Tests flexible formats
		// yyyy-mm-dd hh:mm
		// dd-mm-yyyy hhmm
		std::string command1 = CMD_ADD + SPACE + TASK_A + SPACE + FROM + "2015-10-10 16:00" + SPACE + TO + "10-10-2015 1800";

		Logic logic;
		UIFeedback feedback;
		API::Task task;

		feedback = logic.executeCommand(command1);
		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		task = feedback.getTasksForDisplay()[0];

		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getEndDateTime()));
	}

	TEST_METHOD(integrationDeleteOthers) {
		remove(DEFAULT_FILE.c_str());
		PhysicalStorageHandler::setToTestMode();

		Logic logic;
		UIFeedback feedback;
		API::Task task;

		// delete commands for testing
		std::string deleteByCommandEffect = CMD_DELETE + SPACE + BY + DATE_TIME_1_AFTER;
		std::string deleteByCommandNoEffect = CMD_DELETE + SPACE + BY + DATE_TIME_1;
		std::string deleteFromToCommandEffect = CMD_DELETE + SPACE + FROM + DATE_TIME_2_BEFORE + SPACE + TO + DATE_TIME_3_AFTER;
		std::string deleteFromToCommandNoEffectStart = CMD_DELETE + SPACE + FROM + DATE_TIME_2_BEFORE + SPACE + TO + DATE_TIME_3;
		std::string deleteFromToCommandNoEffectEnd = CMD_DELETE + SPACE + FROM + DATE_TIME_2 + SPACE + TO + DATE_TIME_3_AFTER;
		std::string deleteFromCommandEffect = CMD_DELETE + SPACE + DATE_TIME_2_BEFORE;
		std::string deleteFromCommandNoEffect = CMD_DELETE + SPACE + DATE_TIME_2;

		// Testing DELETE BY command
		feedback = logic.executeCommand(ADD_COMMAND_2);

		// Testing DELETE BY command in the ineffective partition
		try {
			feedback = logic.executeCommand(deleteByCommandNoEffect);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(NO_TASKS_WITH_CONDITION, e);
		}
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		task = feedback.getTasksForDisplay()[0];

		Assert::AreEqual(TASK_B, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing DELETE BY command in the effective partition
		feedback = logic.executeCommand(deleteByCommandEffect);

		Assert::AreEqual((size_t) 0, feedback.getTasksForDisplay().size());

		// Testing DELETE FROM TO command
		feedback = logic.executeCommand(ADD_COMMAND_3);

		// Testing DELETE BY command in the ineffective partition due to start date-time
		try {
			feedback = logic.executeCommand(deleteFromToCommandNoEffectStart);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(NO_TASKS_WITH_CONDITION, e);
		}
		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		task = feedback.getTasksForDisplay()[0];

		Assert::AreEqual(TASK_C, task.getTaskText());
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_3, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing DELETE BY command in the ineffective partition due to end date-time
		try {
			feedback = logic.executeCommand(deleteFromToCommandNoEffectEnd);
			Assert::AreEqual(false, true);

		} catch (std::string &e) {
			Assert::AreEqual(NO_TASKS_WITH_CONDITION, e);
		}
		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		task = feedback.getTasksForDisplay()[0];

		Assert::AreEqual(TASK_C, task.getTaskText());
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_3, boost::posix_time::to_simple_string(task.getEndDateTime()));

		// Testing DELETE FROM TO command in the effective partition
		feedback = logic.executeCommand(deleteFromToCommandEffect);

		Assert::AreEqual((size_t) 0, feedback.getTasksForDisplay().size());

		// Testing DELETE ALL command
		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);

		feedback = logic.executeCommand(CMD_DELETE_ALL);
		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 0, feedback.getTasksForDisplay().size());

		// Testing DELETE COMPLETED command
		feedback = logic.executeCommand(ADD_COMMAND_1);
		feedback = logic.executeCommand(ADD_COMMAND_2);
		feedback = logic.executeCommand(ADD_COMMAND_3);
		feedback = logic.executeCommand(CMD_COMPLETE + SPACE + "1");
		feedback = logic.executeCommand(CMD_COMPLETE + SPACE + "2");
		feedback = logic.executeCommand(CMD_COMPLETE + SPACE + "3");

		feedback = logic.executeCommand(CMD_DELETE_COMPLETED);
		Assert::AreNotEqual(CMD_INVALID, feedback.getFeedbackMessage());
		Assert::AreEqual((size_t) 0, feedback.getTasksForDisplay().size());
	}

	// The following test method tests the program for changes in saved data by the user
	TEST_METHOD(integrationSavedDataChanges) {
		PhysicalStorageHandler::setToTestMode();
		PhysicalStorageHandler storage;
		std::string dataFile = storage.getFilePath();

		remove(dataFile.c_str());

		// Logic only loads from file at construction
		Logic *logic;
		UIFeedback feedback;
		API::Task task;

		// Testing manually added complete entry in the valid entries partition
		std::ofstream saveFile(dataFile.c_str());
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << TASK_A << "\n" << DATE_TIME_1 << "\n" << DATE_TIME_2 << "\n" << "0" << "\n";
		saveFile.close();

		logic = new Logic;
		feedback = logic->executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		task = feedback.getTasksForDisplay()[0];

		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());
		delete logic;

		// Testing manually added incomplete entry in the valid entries partition
		remove(dataFile.c_str());
		saveFile.open(dataFile.c_str());
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << DATE_TIME_1 << "\n" << DATE_TIME_2 << "\n";
		saveFile.close();

		logic = new Logic;

		feedback = logic->executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		task = feedback.getTasksForDisplay()[0];
		Assert::AreEqual(DATE_TIME_1, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());

		delete logic;

		// Testing manually adding task with valid start but invalid end date-time in the valid entries partition
		saveFile.open(dataFile.c_str());
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << TASK_A << "\n" << DATE_TIME_1 << "\n" << NOT_A_DATE_TIME << "\n" << "0" << "\n";
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << TASK_B << "\n" << DATE_TIME_2 << "\n" << TAG_A << "\n" << "0" << "\n";
		saveFile.close();

		logic = new Logic;
		feedback = logic->executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 2, feedback.getTasksForDisplay().size());

		task = feedback.getTasksForDisplay()[0];
		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());
		Assert::AreEqual((size_t) 0, task.getTags().size());

		task = feedback.getTasksForDisplay()[1];
		Assert::AreEqual(TASK_B, task.getTaskText());
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(NOT_A_DATE_TIME, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());
		delete logic;

		// Testing manually added 6th tag that is more than the maximum 5 tags in invalid partition
		saveFile.open(dataFile.c_str());
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << TASK_A << "\n" << DATE_TIME_1 << "\n" << DATE_TIME_2 << "\n" << "0" << "\n";
		saveFile << TAG_A << "\n" << TAG_B << "\n" << TAG_C << "\n" << TAG_D << "\n" << TAG_E << "\n";
		saveFile << TAG_F << "\n";
		saveFile.close();
		std::set<std::string> tags;

		logic = new Logic;
		feedback = logic->executeCommand(CMD_REFRESH);
		task = feedback.getTasksForDisplay()[0];
		tags = task.getTags();

		Assert::AreEqual((size_t) 1, feedback.getTasksForDisplay().size());
		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());
		Assert::AreEqual((size_t) 5, tags.size());
		std::set<std::string>::iterator it = tags.begin();
		Assert::AreEqual(TAG_A, *it);
		Assert::AreEqual(TAG_B, *(++it));
		Assert::AreEqual(TAG_C, *(++it));
		Assert::AreEqual(TAG_D, *(++it));
		Assert::AreEqual(TAG_E, *(++it));
		delete logic;

		// Testing manually adding tag with length > 32 in invalid partition
		const std::string longTag = "#01234567890123456789012345678912";
		saveFile.open(dataFile.c_str());
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << TASK_A << "\n" << DATE_TIME_1 << "\n" << DATE_TIME_2 << "\n" << "0" << "\n";
		saveFile << longTag << "\n";
		saveFile << TASK_IDENTITY_STRING << "\n";
		saveFile << TASK_B << "\n" << DATE_TIME_2 << "\n" << DATE_TIME_3 << "\n" << "0" << "\n";
		saveFile.close();

		logic = new Logic;
		feedback = logic->executeCommand(CMD_REFRESH);
		Assert::AreEqual((size_t) 2, feedback.getTasksForDisplay().size());

		task = feedback.getTasksForDisplay()[0];
		Assert::AreEqual(TASK_A, task.getTaskText());
		Assert::AreEqual(DATE_TIME_1, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());
		Assert::AreEqual((size_t) 0, task.getTags().size());

		task = feedback.getTasksForDisplay()[1];
		Assert::AreEqual(TASK_B, task.getTaskText());
		Assert::AreEqual(DATE_TIME_2, boost::posix_time::to_simple_string(task.getStartDateTime()));
		Assert::AreEqual(DATE_TIME_3, boost::posix_time::to_simple_string(task.getEndDateTime()));
		Assert::AreEqual(false, task.isComplete());
		delete logic;
	}
	};
}
```
###### Storage\PhysicalStorageHandler.cpp
``` cpp
#include "PhysicalStorageHandler.h"


INVALID_FILE_EXCEPTION::INVALID_FILE_EXCEPTION(const std::string eMessage) : std::exception(eMessage.c_str()) {
}


INVALID_PATH_EXCEPTION::INVALID_PATH_EXCEPTION(const std::string eMessage) : std::exception(eMessage.c_str()) {
}

bool PhysicalStorageHandler::isTestMode = false;

PhysicalStorageHandler::PhysicalStorageHandler() {
	_logger = Logger::getInstance();
	if (isTestMode) {
		_filePath = DEFAULT_FILE;
	} else {
		configSaveLocation();
	}
}


PhysicalStorageHandler::~PhysicalStorageHandler(void) {
}

void PhysicalStorageHandler::loadFromFile(std::vector<API::Task>& tasks, std::string filePath) {
	std::ifstream loadFile;
	boost::posix_time::ptime notDateTime;
	std::string identityString = "";
	std::string taskText;
	std::string startDateTimeString;
	std::string endDateTimeString;
	std::string isCompleteString;
	std::string tag;

	_logger->logDEBUG("Loading from file...");

	if (NO_FILE_PATH_SPECIFIED == filePath) {
		loadFile.open(_filePath.c_str());
	} else {
		loadFile.open(filePath.c_str());
	}

	if (!loadFile.is_open()) {
		throw INVALID_FILE_EXCEPTION(INVALID_FILE_ERROR_MESSAGE);
	}
	tasks.clear();

	try {
		while (!loadFile.eof()) {
			API::Task *taskToAdd;

			_logger->logDEBUG("Loading Task...");

			while (!loadFile.eof() && TASK_IDENTITY_STRING != identityString) {
				std::getline(loadFile, identityString);
			}

			std::getline(loadFile, taskText);
			if (TASK_IDENTITY_STRING == taskText) {
				identityString = taskText;
				continue;
			}

			std::getline(loadFile, startDateTimeString);
			if (TASK_IDENTITY_STRING == startDateTimeString) {
				identityString = startDateTimeString;
				taskToAdd = new API::Task(taskText);
				tasks.push_back(*taskToAdd);
				continue;
			}

			std::getline(loadFile, endDateTimeString);
			if (TASK_IDENTITY_STRING == endDateTimeString) {
				identityString = endDateTimeString;
				taskToAdd = new API::Task(taskText);
				tasks.push_back(*taskToAdd);
				continue;
			}

			boost::posix_time::ptime startDateTime;
			if (startDateTimeString != "not-a-date-time") {
				try {
					startDateTime = boost::posix_time::time_from_string(startDateTimeString);
				} catch (boost::exception const & e) {
					_logger->logERROR(startDateTimeString + " is not a format for boost::posix_time");
				}
			}

			boost::posix_time::ptime endDateTime;
			if (endDateTimeString != "not-a-date-time") {
				try {
					endDateTime = boost::posix_time::time_from_string(endDateTimeString);
				} catch (boost::exception const & e) {
					_logger->logERROR(endDateTimeString + " is not a format for boost::posix_time");
				}
			}

			try {
				taskToAdd = new API::Task(taskText, startDateTime, endDateTime);
			} catch (std::exception &e) {
				_logger->logERROR(e.what());

				taskToAdd = new API::Task(taskText, notDateTime, notDateTime);
			}

			std::getline(loadFile, isCompleteString);
			if (isCompleteString == "1") {
				taskToAdd->toggleComplete();
			}

			std::getline(loadFile, tag);
			while (!loadFile.eof() && TASK_IDENTITY_STRING != tag) {
				try {
					taskToAdd->addTag(tag);
				} catch (std::exception &e) {
					_logger->logDEBUG("Tag: " + tag + " Message: " + e.what());
				}
				std::getline(loadFile, tag);
			}
			identityString = tag;

			tasks.push_back(*taskToAdd);
			delete taskToAdd;
		}
	} catch (std::exception e) {
		std::string errorMessage = e.what();

		remove(_filePath.c_str());

		_logger->logERROR("ERROR: " + errorMessage);
		_logger->logERROR("Deleted savedFile");
	}

	return;
}

void PhysicalStorageHandler::saveToFile(std::vector<API::Task>& tasks, std::string filePath) {
	std::ofstream saveFile;

	if (NO_FILE_PATH_SPECIFIED == filePath) {
		saveFile.open(_filePath.c_str());
	} else {
		saveFile.open(filePath.c_str());
	}

	if (!saveFile.is_open()) {
		throw INVALID_PATH_EXCEPTION(INVALID_PATH_ERROR_MESSAGE);
	}

	for (size_t i = 0 ; i < tasks.size() ; ++i) {
		saveFile << TASK_IDENTITY_STRING << std::endl;

		saveFile << tasks[i].getTaskText() << std::endl;

		saveFile << boost::posix_time::to_simple_string(tasks[i].getStartDateTime()) << std::endl;

		saveFile << boost::posix_time::to_simple_string(tasks[i].getEndDateTime()) << std::endl;

		if (tasks[i].isComplete()) {
			saveFile << true << std::endl;
		} else {
			saveFile << false << std::endl;
		}

		std::set<std::string> tags = tasks[i].getTags();
		std::set<std::string>::iterator iter;
		for (iter = tags.begin() ; iter != tags.end() ; ++iter) {
			saveFile << *iter << std::endl;
		}
	}

	return;
}

void PhysicalStorageHandler::setSaveLocation(std::string filePath) {
	std::string path = "";
	std::string file = "";

	_logger->logDEBUG("Inside setSaveLocation");

	splitFileName(filePath, path, file);

	unsigned int validExtensionSize = VALID_FILE_EXTENSION.size();
	if (file.size() <= validExtensionSize ||
		0 != file.compare(file.size() - validExtensionSize, validExtensionSize, VALID_FILE_EXTENSION)) {
			throw INVALID_FILE_EXCEPTION(INVALID_FILE_ERROR_MESSAGE);
	}

	std::fstream dataFile(filePath.c_str());

	if (dataFile.good()) {
		_filePath = filePath;
	} else if (CreateDirectory(path.c_str(), NULL) || ERROR_ALREADY_EXISTS == GetLastError()) {
		_filePath = filePath;
		_logger->logDEBUG("Folder created at new save location");
	} else {
		throw INVALID_PATH_EXCEPTION(INVALID_PATH_ERROR_MESSAGE);
	}

	std::ofstream configFile(CONFIG_FILE.c_str());

	if (configFile.is_open()) {
		configFile.clear();
		configFile << filePath;
	}

	configFile.close();

	_logger->logDEBUG("Exiting setSaveLocation");

	return;
}

void PhysicalStorageHandler::configSaveLocation() {
	std::ifstream configFile(CONFIG_FILE.c_str());
	bool isSuccessful = true;

	_logger->logDEBUG("Configuring _filePath from CONFIG_FILE...");

	if (configFile.is_open()) {
		std::string filePath;
		std::getline(configFile, filePath);

		try {
			setSaveLocation(filePath);
		} catch (INVALID_FILE_EXCEPTION e) {
			_logger->logERROR(e.what());
			isSuccessful = false;
		} catch (INVALID_PATH_EXCEPTION e) {
			_logger->logERROR(e.what());
			isSuccessful = false;
		}

		if (isSuccessful) {
			return;
		}
	}

	try {
		char buffer[MAX_PATH];
		GetModuleFileName(NULL, buffer, MAX_PATH);

		std::string currentLocation(buffer);
		std::string path = "";
		std::string file = "";
		splitFileName(currentLocation, path, file);
		file = DEFAULT_FILE;
		setSaveLocation(path + file);
	} catch (INVALID_FILE_EXCEPTION e) {
		assert(false);
	} catch (INVALID_PATH_EXCEPTION e) {
		assert(false);
	}

	_logger->logDEBUG("Configuration completed");

	return;
}

void PhysicalStorageHandler::splitFileName(std::string fileName, std::string &path ,std::string &file) {
	std::size_t found = fileName.find_last_of("/\\");

	if (std::string::npos != found) {
		path = fileName.substr(0, found + 1);
		file = fileName.substr(found + 1);
	}

	return;
}

std::string PhysicalStorageHandler::getFilePath(void) {
	return _filePath;
}
```
###### Storage\PhysicalStorageHandler.h
``` h
#pragma once

#include <assert.h>
#include <fstream>
#include <string>
#include <vector>
#include "Logger\Logger.h"
#include "../Logic/Task.h"
#include "../boost/date_time/posix_time/posix_time.hpp"

const std::string INVALID_FILE_ERROR_MESSAGE = "Error: File name is not acceptable";
const std::string INVALID_PATH_ERROR_MESSAGE = "Failed to create directory. Please check file path entered";

const std::string DEFAULT_FILE = "defaultSaveFile.txt";
const std::string CONFIG_FILE = "config.txt";
const std::string VALID_FILE_EXTENSION = ".txt";
const std::string TASK_IDENTITY_STRING = "--task--";
const std::string NO_FILE_PATH_SPECIFIED = "No file specified";

class INVALID_FILE_EXCEPTION : public std::exception {
public:
	explicit INVALID_FILE_EXCEPTION(const std::string eMessage);
};

class INVALID_PATH_EXCEPTION : public std::exception {
public:
	explicit INVALID_PATH_EXCEPTION(const std::string eMessage);
};

class PhysicalStorageHandler {
public:
	PhysicalStorageHandler();

	// Loads parameter tasks from data stored in the file at filePath specified. If 
	// filePath is not specified, loads tasks from file at _filePath. If file does 
	// not exist no tasks are loaded.
	//
	// Throws INVALID_FILE_EXCEPTION when filePath is specified and file cannot be opened
	void loadFromFile(std::vector<API::Task> &tasks, std::string filePath = NO_FILE_PATH_SPECIFIED);

	// Saves information about API::Task objects from parameter tasks into the file 
	// at the filePath specified. If filePath is not specified, _filePath is used. 
	// If file does not exist, a new file is created. Tasks data will OVERWRITE 
	// existing file
	//
	// Throws INVALID_PATH_EXCEPTION when file does not exist and cannot be created
	void saveToFile(std::vector<API::Task> &tasks, std::string filePath = NO_FILE_PATH_SPECIFIED);

	// Setter function for filePath of data storage file. Accepts filePath even if 
	// the file already exist. _filePath attribute is updated. filePath is saved at 
	// CONFIG_FILE in the same directory as program.
	//
	// Throws INVALID_FILE_EXCEPTION if the file name is invalid.
	// Throws INVALID_PATH_EXCEPTION if the path is invalid or unable to create folder
	void setSaveLocation(std::string filePath = "");

	std::string getFilePath(void);

	static void setToTestMode() {
		isTestMode = true;
	}

	virtual ~PhysicalStorageHandler(void);

private:
	Logger* _logger;

	std::string _filePath;

	// Gets filePath from CONFIG_FILE and store it in _filePath. If CONFIG_FILE cannot
	// be opened or filePath gotten is invalid, sets _filePath as DEFAULT_FILE instead.
	void configSaveLocation();

	void splitFileName(std::string fileName, std::string &path, std::string &file);

	static bool isTestMode;
};

```
###### UI\UI.cpp
``` cpp
#include "UI.h"

using namespace System;
using namespace System::Windows::Forms;

[STAThread]
int main(array<String^>^ args) {
	Logger* logger = Logger::getInstance();

	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false);

	UI::Swiftask mainWindow;
	Application::Run(%mainWindow);

	return EXIT_SUCCESS;
}

std::string UI::Swiftask::getStdStringCommand(void) {
	System::String^ managed;

	managed = commandBox->Text;
	commandBox->Text = "";

	return msclr::interop::marshal_as<std::string>(managed);
}

void UI::Swiftask::updateUI(void) {
	updateResults();

	clearOutputBox();
	displayInOutputBox();

	return;
}

void UI::Swiftask::updateResults(void) {

	System::String^ managed = gcnew String((*feedback).getFeedbackMessage().c_str());
	results->Text = managed;
	delete managed;

	return;
}

void UI::Swiftask::clearOutputBox(void) {

	while (outputBox->DisplayedRowCount(true)) {
		outputBox->Rows->RemoveAt(0);
	}
	return;
}

void UI::Swiftask::displayInOutputBox(void) {
	System::String ^num = "";
	System::String ^taskText = "";
	System::String ^startDateTime = "";
	System::String ^endDateTime = "";
	System::String ^theTags = "";
	System::String ^doneOrNot = "";
	boost::posix_time::ptime posixStartDateTime;
	boost::posix_time::ptime posixEndDateTime;
	boost::posix_time::ptime posixNowDateTime;
	int rowIndex = 0;
	bool isCompleted = false;
	std::ostringstream convert;

	for (std::vector<API::Task>::iterator it = (*feedback).getTasksForDisplay().begin(); it < (*feedback).getTasksForDisplay().end(); it++) {
		convert << (rowIndex + 1);
		num = gcnew String(convert.str().c_str());
		convert.str(std::string());

		taskText = gcnew String((*it).getTaskText().c_str());

		posixStartDateTime = (*it).getStartDateTime();

		posixEndDateTime = (*it).getEndDateTime();

		std::set<std::string> tagsList;
		tagsList = (*it).getTags();

		isCompleted = (*it).isComplete();

		if (!posixStartDateTime.is_not_a_date_time()) {
			startDateTime = gcnew String(boost::posix_time::to_simple_string(posixStartDateTime).c_str());

		} else {
			startDateTime = gcnew String("-");
		}

		if (!posixEndDateTime.is_not_a_date_time()) {
			endDateTime = gcnew String(boost::posix_time::to_simple_string(posixEndDateTime).c_str());
		} else {
			endDateTime = gcnew String("-");
		}


		std::string stdTags = "";
		if (tagsList.size() != 0) {
			for (std::set<std::string>::iterator iter = tagsList.begin(); iter != tagsList.end(); iter++) {
				stdTags = stdTags + " " + (*iter);
			}
			theTags = gcnew String(stdTags.c_str());
		} else {
			theTags = gcnew String("-");
		}

		outputBox->Rows->Add(num, taskText, startDateTime, endDateTime, theTags);

		formatOutputBox(isCompleted, timePast(posixStartDateTime), timePast(posixEndDateTime), rowIndex);

		rowIndex++;

		delete num;
		delete taskText;
		delete start;
		delete end;
		delete tags;
		delete done;
	}
	return;
}

void UI::Swiftask::formatOutputBoxInitial() {
	Color colHeaderBack = System::Drawing::ColorTranslator::FromHtml("#3F51B5");	// Indigo500
	Color colHeaderFore = System::Drawing::ColorTranslator::FromHtml("#E8EAF6");	// Indigo50
	Color rowHeaderBack = System::Drawing::ColorTranslator::FromHtml("#9FA8DA");	// Indigo200

	outputBox->ColumnHeadersDefaultCellStyle->BackColor = colHeaderBack;
	outputBox->ColumnHeadersDefaultCellStyle->ForeColor = colHeaderFore;

	DataGridViewCellStyle^ colHeaderStyle = outputBox->ColumnHeadersDefaultCellStyle;
	colHeaderStyle->Font = gcnew System::Drawing::Font(outputBox->Font, FontStyle::Bold);

	outputBox->RowHeadersDefaultCellStyle->BackColor = rowHeaderBack;

	//outputBox->GridColor = colHeaderFore;

	outputBox->EnableHeadersVisualStyles = false;
	return;
}

void UI::Swiftask::formatOutputBox(bool isCompleted, dateTimeStat start, dateTimeStat end, int rowIndex) {

	if (0 > rowIndex || outputBox->RowCount <= rowIndex) {
		logger->logDEBUG("rowIndex given out of bounds");
		return;
	}

	formatOutputBoxRow(rowIndex);
	formatOutputBoxStartEndColumn(isCompleted, start, end, rowIndex);
	formatOutputBoxDoneColumn(isCompleted, rowIndex);

	return;
}

void UI::Swiftask::formatOutputBoxRow(int rowIndex) {
	Color oddRow = System::Drawing::ColorTranslator::FromHtml("#E8EAF6");	// Indigo50
	Color evenRow = System::Drawing::ColorTranslator::FromHtml("#C5CAE9");	// Indigo100

	DataGridViewCellStyle^ rowHeaderStyle = outputBox->RowHeadersDefaultCellStyle;

	if (rowIndex % 2) {
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::NUM]->Style->BackColor = oddRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::TASKTEXT]->Style->BackColor = oddRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::START]->Style->BackColor = oddRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::END]->Style->BackColor = oddRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::TAGS]->Style->BackColor = oddRow;
	} else {
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::NUM]->Style->BackColor = evenRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::TASKTEXT]->Style->BackColor = evenRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::START]->Style->BackColor = evenRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::END]->Style->BackColor = evenRow;
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::TAGS]->Style->BackColor = evenRow;
	}

	return;
}

void UI::Swiftask::formatOutputBoxStartEndColumn(bool isCompleted, dateTimeStat start, dateTimeStat end, int rowIndex) {
	Color green = System::Drawing::ColorTranslator::FromHtml("#4CAF50");	// Green500
	Color red = System::Drawing::ColorTranslator::FromHtml("#E57373");		// Red300

	boost::posix_time::ptime posixNowDateTime;
	posixNowDateTime = boost::posix_time::second_clock::local_time();

	if (!isCompleted && !end.isNotDateTime) {
		if (end.hasPast) {
			outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::END]->Style->BackColor = red;
			if (!start.isNotDateTime) {
				outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::START]->Style->BackColor = red;
			}
		} else if (start.hasPast) {
			outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::START]->Style->BackColor = green;
			outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::END]->Style->BackColor = green;
		}
	}

	return;
}

void UI::Swiftask::formatOutputBoxDoneColumn(bool isCompleted, int rowIndex) {
	Color green = System::Drawing::ColorTranslator::FromHtml("#4CAF50");	// Green500
	Color red = System::Drawing::ColorTranslator::FromHtml("#E57373");		// Red300

	if (isCompleted) {
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::DONE]->Style->BackColor = green;
	} else {
		outputBox->Rows[rowIndex]->Cells[OutputBoxColumn::DONE]->Style->BackColor = red;
	}

	return;
}

UI::dateTimeStat UI::Swiftask::timePast(boost::posix_time::ptime posixDateTime) {
	dateTimeStat dateTime;

	if (posixDateTime.is_not_a_date_time()) {
		dateTime.isNotDateTime = true;
		dateTime.hasPast = false;		// Just to give it a value
	} else {
		dateTime.isNotDateTime = false;

		boost::posix_time::ptime posixNowDateTime;
		posixNowDateTime = boost::posix_time::second_clock::local_time();

		if (posixDateTime <= posixNowDateTime) {
			dateTime.hasPast = true;
		} else {
			dateTime.hasPast = false;
		}
	}

	return dateTime;
}
```
###### UI\UI.h
``` h
// The UI of Swiftask uses .NET framework to create a Windows Form application
// Limit length of commandBox to 144 chars because of buffer limit in logic
#pragma once
#include <msclr/marshal_cppstd.h>
#include <sstream>
#include "../Logic/Logic.h"
#include "Logger/Logger.h"
```
###### UI\UI.h
``` h
	// Command called during construction of Swiftask to obtain saved data
	const std::string initialisingCommand = "refresh";

	enum OutputBoxColumn {
		NUM, TASKTEXT, START, END, TAGS, DONE
	};

	struct dateTimeStat {
		bool isNotDateTime;
		bool hasPast;
	};

	public ref class Swiftask : public System::Windows::Forms::Form {
	private: 
		Logic* logic;
		UIFeedback* feedback;
		Logger* logger;

	private: 
```
###### UI\UI.h
``` h
		Swiftask(void) {
			InitializeComponent();

			logger = Logger::getInstance();

			formatOutputBoxInitial();

			logic = new Logic();
			feedback = new UIFeedback;

			(*feedback) = logic->executeCommand(initialisingCommand);
			displayInOutputBox();
		}
	private: 
		// Gets user command input from commandBox and return it in std::string
		// Resets the commandBox
		std::string getStdStringCommand(void);

		// A method to call specialised methods to update parts of UI component
		void updateUI(void);

		// The three following methods update specific parts of UI component
		// These methods takes information from private attribute feedback for update
		void updateResults(void);
		void clearOutputBox(void);
		void displayInOutputBox(void);

		// Format colours of headers in outputBox
		void formatOutputBoxInitial(void);

		// A method to call specialised methods to format colours for fonts and backgrounds in outputBox
		// Colours formatting is done row by row
		// Pre-condition:	rowIndex given should not be out of bounds
		void formatOutputBox(bool isCompleted, dateTimeStat start, dateTimeStat end, int rowIndex);

		// This method set the background of odd rows of outputBox in one colour
		// and even rows in another colour
		// Pre-condition:	rowIndex given should not be out of bounds
		void formatOutputBoxRow(int rowIndex);

		// This method colours cells under start and end column according to current system time
		// Pre-condition:	start and end are based on startDateTime and endDateTime respectively.
		//					startDateTime should happen chronologically before endDateTime.
		//					rowIndex given should not be out of bounds
		void formatOutputBoxStartEndColumn(bool isCompleted, dateTimeStat start, dateTimeStat end, int rowIndex);

		// This method colours the cell under done column according to isCompleted
		// Pre-condition:	rowIndex given should not be out of bounds
		void formatOutputBoxDoneColumn(bool isCompleted, int rowIndex);

		// Helper function for determining if the given posix time is a date time
		// If it is a date time, checks if the time has past
		// Information is returned in a struct dateTimeStat
		dateTimeStat timePast(boost::posix_time::ptime posixDateTime);

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~Swiftask()
		{
			if (components)
			{
				delete components;
				delete logic;
			}
		}
	private: 
```
###### UI\UI.h
``` h
		// When the enter key is pressed, UI will take in the command string and pass it to the Logic component
		// for execution. An UIFeedback object is returned from Logic and the UI is updated.
		System::Void commandBox_KeyDown(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
			if (e->KeyCode == Keys::Enter) {
				bool isValid = true;
				std::string eMessage;
				std::string commandString = getStdStringCommand();

				assert(feedback != NULL);

				logger->logDEBUG("UI calling Logic for : " + commandString);

				try {
					(*feedback) = logic->executeCommand(commandString);
				} catch (std::string &e) {
					isValid = false;
					eMessage = e;
					logger->logDEBUG("UI caught std::string : " + eMessage);
				} catch (std::exception &e) {
					isValid = false;
					eMessage = e.what();
					logger->logDEBUG("UI caught std::string : " + eMessage);
				}

				logger->logDEBUG("UIFeedback returned from logic");

				if (isValid) {
					updateUI();
				} else {
					System::String^ managed = gcnew String(eMessage.c_str());
					results->Text = managed;
				}
			}

			return;
		}
	};
}
```
